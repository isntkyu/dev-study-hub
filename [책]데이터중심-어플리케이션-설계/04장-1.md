## 부호화와 발전

너무 어렵다. 4장 시작만 3번째만에 그나마 조금 읽힌다.
반드시 내용을 정리해놓으며 제대로 이해하고 싶다.

---

스키마가 변경될 때,
애플리케이션 코드에 대한 변경이 발생한다. 하지만 대규모 애플리케이션 코드에는 즉시 반영이 안됨.

이 때, 몇 개의 노드를 먼저 배포하고 서서히 모든 노드에서 실행되게하는 **순회식 업그레이드**

> 카나리 배포랑 비슷한 개념인듯..

단계적 롤아웃이라고도 불린다.

클라이언트 측 애플리케이션은 사용자가 업데이트를 하지 않으면 변경 못시킨다.

> 모바일 앱의 경우

이 말은 새로운 코드와 옛 버전이 공존할 수 있다는 얘기다.
시스템이 원활하려면 양방향 호환성을 유지해야한다.

> 실무에서 모바일 앱에서 사용하는 API 신버전을 배포나갈경우, 구버전의 요청도 커버할 수 있도록 코딩해야했다.

---

### 데이터 부호화 형식

메모리에는 객체, 구조체, 리스트, 배열, 해시테이블, 트리 등 다양한 데이터구조로 유지되고,
CPU에서 효율적으로 접근, 조작할 수 있게 최적화된다. 보통은 포인터를 이용한다.

다르게, 데이터를 파일에 쓰거나 네트워크로 전송하려면 바이트열이 필요하다 (ex, JSON)
이 바이트열은 메모리에서 사용하는 데이터구조와 상당히 다르다. (json은 포인터도 이해할 수 없음)

두 가지 표현으 전환을
**복호화** <-> **부호화** 라고한다. (복호화가 바이트열을 인메모리로.)
== 언마샬링 <-> 마샬링.

---

### 언어별 형식

많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장함.

하지만 다양한 이유로 일시적인 목적외에는 언어 내장 부호화를 사용하는건 좋지 않다.

- 다른 언어에서 데이터 읽기 매우 어려움.
- 보안문제(공격자가 바이트를 복호화하는 애플리케이션을 얻을 수 있으면 위험함)
- 데이터 버전 관리 어려움
- CPU 효율성. 특히, 자바의 내장 직렬화는 성능이 나쁘기로 유명

---

### JSON, XML, CSV, 이진 문자열

- json: 큰 수를 다룰 때 결점이 있음. 부동소수점 수에서는 정확하지 못할 수 있음(javascript)
- json, xml 은 이진 문자열을 지원하지 않아서 이진문자열의 유용함을 사용하기 위해 base64를 사용한다. 다만 데이터 크기가 증가한다.
- csv: 스키마가 없으므로 로우, 칼럼 의미는 애플리케이션 레벨에서 지정해야한다.

---

### 이진 부호화

**메시지팩**

메시지 팩은 json 용 이진 부호화 형식이다.
아주 작은 바이트의 절약 이득이 있다.
하지만 json이 갖는 텍스트, 즉 사람의 가독성을 해칠 만큼의 가치가 있는지는 의문.

**스리프트와 프로토콜 버퍼**

스키마가 필요한 이진 부호화 라이브러리

**아브로**

---

## 데이터 플로

상식타임

- 서버가 공개한 API 를 서비스.
- 서비스 지향 설계 (SOA) -> 오늘날 MSA 가 됨.
- 서비스와 통신하기 위한 프로토콜로 HTTP 를 사용할 때 웹 서비스라 함.
- 미들웨어: MSA에서 다른 서비스에 요청을 지원하는 소프트웨어
- REST:
  http 원칙을 토대로 한 설계철학. 간단한 데이터 타입을 강조하며 url 로 리소스를 식별한다. 캐시제어, 인증, 콘텐츠 유형 협상등에 http 기능을 사용한다.
- SOAL:
  네트워크 API 요청을 위한 XML 기반 프로토콜. http 상에서 일반적으로 샤용하지만 독립적이며 http 의 기능을 거의 사용하지 않는다.
  WSDL 이라는 xml 기반 언어를 사용해 기술한다. 정적타입 프로그래밍언어에는 유용할 수 있지만 동적 언어에서는 떨어진다.
  WSDL은 사람이 읽을 수 있게 설계된 것이 아니고, ide에 크게 의존한다.

---

### RPC

원격 프로시저 호출.
네트워크 요청으로 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것처럼 사용.
이를 위치 투명성이라 한다.
결함: 네트워크 문제에 의존적이다. 로컬 함수의 실패가 timeout 에러로 확인될 수 있는 등
결함2: 포인터를 효율적으로 전달할 수 없다. 매개변수를 네트워크에 전송하게끔 부호화해야하는데 객체의 경우 문제가 될 수 있다.
결함3: 다른 프로그래밍 언어간의 소통을 구현하기 힘들다. 데이터 타입이 다르기 떄문

### gRPC

프로토콜 버퍼를 활용한 RPC 구현.
차세대 RPC 프레임워크는 네트워크 원격 요청이 로컬 함수 호출과 다르다는 것을 분명히 한다.
gRPC는 하나의 요쳥과 하나의 응답. 시간에 따른 일련의 요청과 응답으로 구성된 스트림을 지원한다.

성능은 좋을지 모르나 RESTful은 실험과 디버깅에 적합하고 다양한 도구 생태계에 큰 이점이있다. (curl 등)

RPC 프레임워크의 주요 초점은 같은 데이터 센터 내의 서비스간 요청에 있다.(MSA)

클라이언트와의 호환성. 즉, API 버전관리는 어떤 방식에 대한 합의는 없다.
RESTful 에서는 url 이나 HTTP accept 헤더에 버전을 사용하는 방식이 일반적임.

---

### 비동기 메시지 전달 시스템

클라이언트요청을 다른 프로세스에 전달한다는 점에선
RPC와 유사하지만 메시지 브로커, 메시지 지향 미들웨어라는 중간단계를 거친다는 점에서는 데이터베이스와 유사하다.
(데이터베이스: 한 프로세스에서 부호화한 데이터를 다른 프로세스에서 읽게하는 방식의 소통)

#### 메시지 브로커를 사용의 RPC에 비한 장점.

- 수신자가 과부하상태라면 브로커가 버퍼처럼 동작.
- 죽은 프로세스에 메시지를 다시 전달할 수 있다(유실방지)
- 송신자가 ip, port를 알 필요가 없다(클라우드에서 유리)
- 하나의 메시지를 여러 수신자에게 전송가능
- 퍼블리쉬와 컨슘의 명백한 역할 분리 (단방향)

**분산 액터 프레임워크**
동시성(잠금, 데드락)을 위한 프로그래밍 모델. (아카, 올리언스, 얼랭)
기본적으로 액터 프로그래밍 모델과 메시지브로커를 단일로 통합

---

## 정리

데이터 부호화 형식과 호환성 속성

- 프로그래밍언어에 특화돤 부호화(내장 부호화 기능)는 그 언어로 제한되어, 상위 하위 호환성에 문제가 있다.
- json, xml, csv 같은 텍스트 형식이 널리 사용됨. 데이터 타입에 대한 모호한 점이 존재하긴함. 숫자나 이진문자열
- 스리프트, 프로토콜 버퍼, 아브라 같은 이진 스키마 기반 형식 효율적인 부호화를 제공하지만 사람이 읽기 힘듦.

데이터 플로 모드

- 데이터베이스: 기록하는 프로세스가 부호화, 읽는 프로세스가 복호화
- REST, RPC: 클라이언트가 부호화, 서버는 복호화하고 응답을 부호화, 클라이언트가 응답을 복호화
- 비동기 메시지 전달, 액터: 송신자가 부호화, 수신자가 복호화 과정을 서로 전송함

---

\*상하위 호환성과 순회식 업그레이드를 위해.
