## 부호화와 발전

너무 어렵다. 4장 시작만 3번째만에 그나마 조금 읽힌다.
반드시 내용을 정리해놓으며 제대로 이해하고 싶다.

---

스키마가 변경될 때,
애플리케이션 코드에 대한 변경이 발생한다. 하지만 대규모 애플리케이션 코드에는 즉시 반영이 안됨.

이 때, 몇 개의 노드를 먼저 배포하고 서서히 모든 노드에서 실행되게하는 **순회식 업그레이드**

> 카나리 배포랑 비슷한 개념인듯..

단계적 롤아웃이라고도 불린다.

클라이언트 측 애플리케이션은 사용자가 업데이트를 하지 않으면 변경 못시킨다.

> 모바일 앱의 경우

이 말은 새로운 코드와 옛 버전이 공존할 수 있다는 얘기다.
시스템이 원활하려면 양방향 호환성을 유지해야한다.

> 실무에서 모바일 앱에서 사용하는 API 신버전을 배포나갈경우, 구버전의 요청도 커버할 수 있도록 코딩해야했다.

---

### 데이터 부호화 형식

메모리에는 객체, 구조체, 리스트, 배열, 해시테이블, 트리 등 다양한 데이터구조로 유지되고,
CPU에서 효율적으로 접근, 조작할 수 있게 최적화된다. 보통은 포인터를 이용한다.

다르게, 데이터를 파일에 쓰거나 네트워크로 전송하려면 바이트열이 필요하다 (ex, JSON)
이 바이트열은 메모리에서 사용하는 데이터구조와 상당히 다르다. (json은 포인터도 이해할 수 없음)

두 가지 표현으 전환을
**복호화** <-> **부호화** 라고한다. (복호화가 바이트열을 인메모리로.)
== 언마샬링 <-> 마샬링.

---

### 언어별 형식

많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 내장함.

하지만 다양한 이유로 일시적인 목적외에는 언어 내장 부호화를 사용하는건 좋지 않다.

- 다른 언어에서 데이터 읽기 매우 어려움.
- 보안문제(공격자가 바이트를 복호화하는 애플리케이션을 얻을 수 있으면 위험함)
- 데이터 버전 관리 어려움
- CPU 효율성. 특히, 자바의 내장 직렬화는 성능이 나쁘기로 유명

---

### JSON, XML, CSV, 이진 문자열

- json: 큰 수를 다룰 때 결점이 있음. 부동소수점 수에서는 정확하지 못할 수 있음(javascript)
- json, xml 은 이진 문자열을 지원하지 않아서 이진문자열의 유용함을 사용하기 위해 base64를 사용한다. 다만 데이터 크기가 증가한다.
- csv: 스키마가 없으므로 로우, 칼럼 의미는 애플리케이션 레벨에서 지정해야한다.

---

### 이진 부호화

**메시지팩**

메시지 팩은 json 용 이진 부호화 형식이다.
아주 작은 바이트의 절약 이득이 있다.
하지만 json이 갖는 텍스트, 즉 사람의 가독성을 해칠 만큼의 가치가 있는지는 의문.

**스리프트와 프로토콜 버퍼**

스키마가 필요한 이진 부호화 라이브러리

**아브로**
