# 저장소와 검색

## index

모든 index는 쓰기 성능을 떨어뜨릴 수 밖에 없는 트레이드오프가 있음. (index도 갱신해줘야 하기 때문)

---

## Hash Index

**Log Example**

인덱스를 해시맵으로 {key, ByteOffset} 으로 인메모리에 저장.

\*바이트오프셋: 한 칸에 1바이트크기의 데이터 저장공간에서의 주소( 몇 번쨰 바이트에 데이터가 위치하는지 )

해시맵을 인메모리에 유지하기 때문에 고성능의 읽기, 쓰기가 가능하다.

하지만 key를 계속 추가한다면 디스크 공간이 부족할 수 있다.
그럴 경우엔 특정 크기의 세그먼트로 나누어 관리한다.

- 특정 크기의 세그먼트에 디스크 용량이 도달
- 현재 세그먼트를 컴팩션하고 세그먼트 닫기 (컴팩션: 최신 갱신 값을 유지)
- 새로운 세그먼트 열기.

제약) 키가 너무 많으면 디스크공간에 제약이 있다.

- 해시 인덱스의 치명적 단점: 범위 질의에 약함. DB 인덱스로 사용되지 않는 가장 큰 이유라고 생각됨. 떄문에 B-tree 로 사용

---

## SS 테이블( 정렬된 문자열 테이블 )

키-값 쌍을 키로 정렬.

-> 로그 구조화 병합 트리(LSM)

범위 질의등 다양한 장점이 추가됨.

---

## B-tree

SS테이블과 비슷한 점은 키-값이 정렬되어있다는 것 뿐.
전통적으로 4kb 크기의 고정 크기 블록이나 페이지로 나눔. 디스크가 고정 크기 블록으로 배열되기 때문에 이런 설계는 하드뒈어와 더 밀접한 관련이 있다.

한 번에 하나의 블록이나 페이지에 읽기 또는 쓰기가 이루어지고, 하나의 페이지는 다른 페이지를 참조할 수 있다.(포인터와 비슷하지만 메모리 아닌 디스크에 저장)

---

## B-트리 vs LSM 트리

LSM은 쓰기에서 빠르고 B트리는 읽기에서 빠르다.
LSM은 각 컴팩션 단계에서 여러 가지 데이터구조와 ss 테이블을 확인해야 하기 때문이다.

LSM 장점

- 쓰기 처리량을 높게 유지할 수 있다.
- 압축률이 더 좋다.(비트리는 파편화로 인해 사용하지 않는 공간이 남는다.)

LSM 단점

- 컴팩션과정에 진행중인 읽기 쓰기에 영향을 줄 수 있다.
- 높은 쓰기 처리량에도 컴팩션이 유입쓰기 속도가 빠르면 그 를 따라가지 못한다.
- **같은 키의 다중복사본이 존재할 수 있다**. (비트리는 정확히 한 곳에 존재)

---

## 기타 인덱스

기본키 인덱스는 키-값 인덱스의 대표적인 예다.
보조 인덱스: 효율적인 조인 수행에 도움이 크다.(create index 명령)
기본키와 주요 차이점은 키가 고유하지 않다는점. 로우 식별자를 추가해 각 키를 고유하게 만들 수 있다.

---

## 클러스터드 인덱스

인덱스에서 키는 질의의 검색대상이고 값은 다른 로우에 대한 참조거나 실제 로우(값)이다.

전자의 경우 힙파일에 순서없이 데이터를 저장한다.

힙파일 방식의 경우 새로운 값이 갱신될 때 이전 값보다 많은 공간이 필요하면 상황이 복잡해진다.
이 때 성능에 불이익이 많다.

이런 상황에서는 후자의 경우가 바람직하다 이를 **클러스터드 인덱스**라 한다.

> MySQL의 이노디비에서는 기본키는 클러스터드 인덱스이고 보조인덱스는 기본키를 참조한다.

커버링색인이라는 절충안이 있다. 테이블 컬럼일부만 저장하는 것이다.
이런 경우에 인덱스만으로 질의응답이 가능할 수 있는데 이런 경우를 인덱스가 질의를 커버했다고 한다.

하지만 읽기 성능이 높은 만큼 쓰기 성능에 오버헤드가 발생한다.
