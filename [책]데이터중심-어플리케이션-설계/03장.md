# 저장소와 검색

## index

모든 index는 쓰기 성능을 떨어뜨릴 수 밖에 없는 트레이드오프가 있음. (index도 갱신해줘야 하기 때문)

---

## Hash Index

**Log Example**

인덱스를 해시맵으로 {key, ByteOffset} 으로 인메모리에 저장.

\*바이트오프셋: 한 칸에 1바이트크기의 데이터 저장공간에서의 주소( 몇 번쨰 바이트에 데이터가 위치하는지 )

해시맵을 인메모리에 유지하기 때문에 고성능의 읽기, 쓰기가 가능하다.

하지만 key를 계속 추가한다면 디스크 공간이 부족할 수 있다.
그럴 경우엔 특정 크기의 세그먼트로 나누어 관리한다.

- 특정 크기의 세그먼트에 디스크 용량이 도달
- 현재 세그먼트를 컴팩션하고 세그먼트 닫기 (컴팩션: 최신 갱신 값을 유지)
- 새로운 세그먼트 열기.

제약) 키가 너무 많으면 디스크공간에 제약이 있다.

- 해시 인덱스의 치명적 단점: 범위 질의에 약함. DB 인덱스로 사용되지 않는 가장 큰 이유라고 생각됨. 떄문에 B-tree 로 사용
