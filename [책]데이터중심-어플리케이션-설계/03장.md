# 저장소와 검색

## index

모든 index는 쓰기 성능을 떨어뜨릴 수 밖에 없는 트레이드오프가 있음. (index도 갱신해줘야 하기 때문)

---

## Hash Index

**Log Example**

인덱스를 해시맵으로 {key, ByteOffset} 으로 인메모리에 저장.

\*바이트오프셋: 한 칸에 1바이트크기의 데이터 저장공간에서의 주소( 몇 번쨰 바이트에 데이터가 위치하는지 )

해시맵을 인메모리에 유지하기 때문에 고성능의 읽기, 쓰기가 가능하다.

하지만 key를 계속 추가한다면 디스크 공간이 부족할 수 있다.
그럴 경우엔 특정 크기의 세그먼트로 나누어 관리한다.

- 특정 크기의 세그먼트에 디스크 용량이 도달
- 현재 세그먼트를 컴팩션하고 세그먼트 닫기 (컴팩션: 최신 갱신 값을 유지)
- 새로운 세그먼트 열기.

제약) 키가 너무 많으면 디스크공간에 제약이 있다.

- 해시 인덱스의 치명적 단점: 범위 질의에 약함. DB 인덱스로 사용되지 않는 가장 큰 이유라고 생각됨. 떄문에 B-tree 로 사용

---

## SS 테이블( 정렬된 문자열 테이블 )

키-값 쌍을 키로 정렬.

-> 로그 구조화 병합 트리(LSM)

범위 질의등 다양한 장점이 추가됨.

---

## B-tree

SS테이블과 비슷한 점은 키-값이 정렬되어있다는 것 뿐.
전통적으로 4kb 크기의 고정 크기 블록이나 페이지로 나눔. 디스크가 고정 크기 블록으로 배열되기 때문에 이런 설계는 하드뒈어와 더 밀접한 관련이 있다.

한 번에 하나의 블록이나 페이지에 읽기 또는 쓰기가 이루어지고, 하나의 페이지는 다른 페이지를 참조할 수 있다.(포인터와 비슷하지만 메모리 아닌 디스크에 저장)

---

## B-트리 vs LSM 트리

LSM은 쓰기에서 빠르고 B트리는 읽기에서 빠르다.
LSM은 각 컴팩션 단계에서 여러 가지 데이터구조와 ss 테이블을 확인해야 하기 때문이다.

LSM 장점

- 쓰기 처리량을 높게 유지할 수 있다.
- 압축률이 더 좋다.(비트리는 파편화로 인해 사용하지 않는 공간이 남는다.)

LSM 단점

- 컴팩션과정에 진행중인 읽기 쓰기에 영향을 줄 수 있다.
- 높은 쓰기 처리량에도 컴팩션이 유입쓰기 속도가 빠르면 그 를 따라가지 못한다.
- **같은 키의 다중복사본이 존재할 수 있다**. (비트리는 정확히 한 곳에 존재)

---

## 기타 인덱스

기본키 인덱스는 키-값 인덱스의 대표적인 예다.
보조 인덱스: 효율적인 조인 수행에 도움이 크다.(create index 명령)
기본키와 주요 차이점은 키가 고유하지 않다는점. 로우 식별자를 추가해 각 키를 고유하게 만들 수 있다.

---

## 클러스터드 인덱스

인덱스에서 키는 질의의 검색대상이고 값은 다른 로우에 대한 참조거나 실제 로우(값)이다.

전자의 경우 힙파일에 순서없이 데이터를 저장한다.

힙파일 방식의 경우 새로운 값이 갱신될 때 이전 값보다 많은 공간이 필요하면 상황이 복잡해진다.
이 때 성능에 불이익이 많다.

이런 상황에서는 후자의 경우가 바람직하다 이를 **클러스터드 인덱스**라 한다.

> MySQL의 이노디비에서는 기본키는 클러스터드 인덱스이고 보조인덱스는 기본키를 참조한다.

커버링색인이라는 절충안이 있다. 테이블 컬럼일부만 저장하는 것이다.
이런 경우에 인덱스만으로 질의응답이 가능할 수 있는데 이런 경우를 인덱스가 질의를 커버했다고 한다.

하지만 읽기 성능이 높은 만큼 쓰기 성능에 오버헤드가 발생한다.

---

## 데이터 웨어하우스

비즈니스 트랜잭션 처리시스템과 별개로 분석 시스템을 위한 데이터베이스를 따로 관리하기 시작했고 이를 데이터 웨어하우스라 부른다.( <-> OLTP 데이터베이스)

실제로 우리 회사에서도 **AWS DMS**를 이용해 **GCP 빅쿼리**로 주기적으로 분석을 위한 데이터를 넣는다.

이 과정을 ETL(extract-transform-load) 라고한다. (이 과정에서 분석친화적인 스키마로 변환하기도 함)

### 사실 테이블

각 로우가 이벤트, 혹은 트랜잭션에 해당함. 각 다른 테이블의 pk만을 쫙 담고있음.
**모든 컬럼이 외래키**.

### 칼럼 지향

사실 테이블은 컬럼이 매우많고 실제로는 필요한 몇 개의 컬럼만 select 한다.
이 때문에 관계형 디비(로우 지향)과 다른게 컬럼으로 묶어 저장한다.

이 떄, 컬럼엔 같은 값이 연속되는 비효율적인 경우가 많다.
그래서 컬럼압축을 **비트맵 인덱스**로 활용한다.

대략적)
컬럼의 값들을 unique by 한다.
로우들이 그 값들을 갖고 있는지 아닌지 여부를 1, 0으로 기록한다.

### 구체화 뷰

SQL의 집계함수의 결과값을 캐싱한 뷰

**데이터 큐브** : 다차원으로 그룹화한 집계 테이블 뷰. 실제 큐브를 상상하면 된다.

---

## 정리

OLTP 디비는 디스크 탐색이 병목이다.

데이터 웨어하우스는 디스크 대역폭이 병목이다.
