## 5장 복제

전체 데이터셋을 복사하는 방법에 대한 챕터 (6장에서는 복사하기 너무 큰 데이터셋에 대한 파티셔닝을 학습)

복제의 모든 어려움은 모든 복제된 데이터의 **변경**에 있다.

노드 간 변경을 위한 복제 알고리즘 3가지

- 싱글리더
- 멀티리더
- 리더리스

---

### 리더와 팔로워

팔로워(==레플리카, slave, secondary)

> RDS ro 전용 레플리카를 두고 쓰는 예, 레디스 레플리카(업그레이드 용)

리더 혹은 primary, master

리더가 팔로워에게 복제로그나 변경 스트림을 전송하여 리더가 처리한 순서와 동일하게 팔로워들이 쓰기를 적용한다.
(쓰기는 리더에게만 허용된다는 특징, 팔로워는 ro)

이 방식은 카프카, 래빗mq 등의 고가용성 큐 분산 브로커에도 사용됨.

---

### 복제의 동기와 비동기

- 동기

사용자의 요청 -> 리더 -> 팔로워 -> 팔로워의 ok -> 사용자에게 응답

- 비동기

리더는 팔로워의 ok 를 기다리지 않음.

현실적으로 동기식을 사용한다는 것은, 팔로워 하나를 동기식으로 하고 나머지를 비동기식으로 하는 것을 의미한다.(반동기식)
팔로워가 많거나 지리적으로 분산되어있다면 완전 비동기식 복제를 많이 선택한다.

---

### 새로운 팔로워 설정

스냅샷을 복사 -> 스냅샷 이후의 데이터 변경내용 리더에게 요청.

---

### 팔로워장애: 따라잡기 복구

리더로부터 수신한 모든 변경 로그를 로컬디스크에 기록한다.
중단 되기 직전의 트랜잭션을 알아낸다.

---

### 리더장애: 장애 복구

팔로워 하나를 리더로 승격. 보통 수동으로 진행.

1. 리더 장애 판단법
   - 대부분 타임아웃으로 판단. 다양한 원인이 있기 때문
2. 최신 데이터의 노드를 새로운 리더로 선택
3. 새로운 리더를 위한 시스템 설정

**깃허브 장애사례**  
유효하지 않은 mysql 팔로워가 리더로 승격됨.
새로운 리더의 auto-increment 기본키가 뒤쳐지게 되어서 레디스와 기본키 불일치를 일으킴.

---

### 구문 기반 복제의 문제점(리더 복구)

모든 sql 구분을 재실행하여 복제하는 경우.

- NOW(), RAND() 함수 문제
- auto-increment나 데이터의 조건에의한 변경때문에 순차적으로 실행해야할 때, 트랜잭션의 동시실행이 불가함.
- 트리거, 프로시저, 펑션의 사이드 이펙트

---

### 쓰기 전 로그 배송

- 저장소 엔진은 모든 쓰기(write)를 로그에 기록함
- 팔로워에게 동일한 로그를 배송하여 싱크를 맞출 수 있음.(postgre, oracle에서 이렇게 함)
- 그러나 로그는 저수준 정보라서 소프트웨어 버전등의 정보등을 맞출 수 없다.
- 팔로워가 리더보다 새로운 버전 업그레이드를 가능하게 허용하면
- 그 팔로워를 리더로 승격시키면서 리더장애 복구가 가능.

---

### 논리적 로그 복제 / 로우 기반 로그 복제

저장소 엔진과 분리하기 위해 다른 형식을 사용한 로그 **논리적 로그**

관계형 디비의 논리적 로그는 로우 단위의 레코드 열이다.

하위 호환성이 좋다. 심지어 다른 저장소 엔진을 사용할 수도 있다.
외부 애플리케이션, 오프라인 분석이나 파싱하기 좋다. (변경 데이터 캡처 라고도 부름)

---

### 복제 지연 문제

팔로워둘을 확장해서 읽기 요청을 분산하는 읽기 확장(read-scaling)
은 실제로는 비동기식 복제에서만 동작할 수 있다.
완전 동기식 복제는 전체 노드가 잠기기 때문에.

아쉽게도 비동기 팔로워가 데이터 복제가 늦어지는 아주 짧은 순간이 분명 존재하기 된다.
최종적으로는 일치하게 된다.(최종적 일관성)

이 지연이 크면 문제가 된다. 나도 실제로 회사에서 복제 지연 문제를 여러번 마주해 보았다.

---

### 자신이 쓴 내용 읽기(복제 지연 문제 사례)

복제 지연 문제의 예시로
사용 자가 방금 쓴 글을 읽어야 할 때, 사용자가 읽는 팔로워 노드에게까지 쓰기 요청이 닿지 않았을 수 있는 사례이다.

이런 상황에서 **쓰기 후 읽기 일관성**을 보장하기 위해서 사용자가 페이지 재로딩했을 때 자신이 방금 제출한 갱신을 볼 수 있는 것을 보장해야한다.
다른 사용자에 대해서까지는 보장하지 않는다. 다양한 기법이 있다.

- 사용자가 수정한 내용은 리더 노드에서 읽는다. 수정된 정보를 식별할 수 있는 경우에 용이하다. 예를 들어 SNS 프로필은 사용자 본인만 수정할 수 있기 때문에 본인의 프로필은 리더 노드에서 읽고 타인의 프로필은 팔로워 노드에서 읽는다.
- 마지막 갱신 시각을 찾아서 일정 시간동안(ex 1분)은 리더에서 읽기를 수행한다. 일정 시간(ex 1분)보다 복제 지연이 큰 팔로워에 대해선 질의를 금지할 수 있다.
- 클라이언트의 타임스탬프를 사용하여(갱신에 반영) 복제 서버가 최신 내용이 아닌 경우 대기시키거나 다른 노드에서 읽는다.
- 디바이스 간 일관성까지 유지하려면 상당히 복잡하다.
