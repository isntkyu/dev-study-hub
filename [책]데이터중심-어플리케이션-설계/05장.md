## 5장 복제

전체 데이터셋을 복사하는 방법에 대한 챕터 (6장에서는 복사하기 너무 큰 데이터셋에 대한 파티셔닝을 학습)

복제의 모든 어려움은 모든 복제된 데이터의 **변경**에 있다.

노드 간 변경을 위한 복제 알고리즘 3가지

- 싱글리더
- 멀티리더
- 리더리스

---

### 리더와 팔로워

팔로워(==레플리카, slave, secondary)

> RDS ro 전용 레플리카를 두고 쓰는 예, 레디스 레플리카(업그레이드 용)

리더 혹은 primary, master

리더가 팔로워에게 복제로그나 변경 스트림을 전송하여 리더가 처리한 순서와 동일하게 팔로워들이 쓰기를 적용한다.
(쓰기는 리더에게만 허용된다는 특징, 팔로워는 ro)

이 방식은 카프카, 래빗mq 등의 고가용성 큐 분산 브로커에도 사용됨.

---

### 복제의 동기와 비동기

- 동기

사용자의 요청 -> 리더 -> 팔로워 -> 팔로워의 ok -> 사용자에게 응답

- 비동기

리더는 팔로워의 ok 를 기다리지 않음.

현실적으로 동기식을 사용한다는 것은, 팔로워 하나를 동기식으로 하고 나머지를 비동기식으로 하는 것을 의미한다.(반동기식)
팔로워가 많거나 지리적으로 분산되어있다면 완전 비동기식 복제를 많이 선택한다.

---

### 새로운 팔로워 설정

스냅샷을 복사 -> 스냅샷 이후의 데이터 변경내용 리더에게 요청.

---

### 팔로워장애: 따라잡기 복구

리더로부터 수신한 모든 변경 로그를 로컬디스크에 기록한다.
중단 되기 직전의 트랜잭션을 알아낸다.

---

### 리더장애: 장애 복구

팔로워 하나를 리더로 승격. 보통 수동으로 진행.

1. 리더 장애 판단법
   - 대부분 타임아웃으로 판단. 다양한 원인이 있기 때문
2. 최신 데이터의 노드를 새로운 리더로 선택
3. 새로운 리더를 위한 시스템 설정

**깃허브 장애사례**  
유효하지 않은 mysql 팔로워가 리더로 승격됨.
새로운 리더의 auto-increment 기본키가 뒤쳐지게 되어서 레디스와 기본키 불일치를 일으킴.

---

### 구문 기반 복제의 문제점(리더 복구)

모든 sql 구분을 재실행하여 복제하는 경우.

- NOW(), RAND() 함수 문제
- auto-increment나 데이터의 조건에의한 변경때문에 순차적으로 실행해야할 때, 트랜잭션의 동시실행이 불가함.
- 트리거, 프로시저, 펑션의 사이드 이펙트
