# JavaScript V8

## JIT 컴파일러

동적, 정적 컴파일러의 장점을 취함.
런타임에서 최적화할 코드가 있는지 수집하고 컴파일 및 최적화

## 인터프리터

컴파일하지 않고 한줄 씩 읽어 실행
실행파일 생성하지 않아서 실행시간은 빠르나 속도는 느림

## 컴파일러

기계어로 번역된 실행파일을 만든다.

##V8 엔진

ecmascript 규격의 c++
JIT 컴파일러 채택

## V8 동작방식(v9.1)

Parser가 문법오류를 잡고 AST 만듦
Ignition이 AST를 (추상화트리) 바이트코드를 만듦
바이트코드가 실행되기 전단계에서 실행컨텍스트가 생성
SparkPlug(비최적화), TurboFan(최적화) 컴파일러중에 선택함
TurboFan이 역최적화하지않도록 하면 좋음

### 왜 비최적화컴파일러(SparkPlug)가 도입되었나

너무빠르게 최적화할 때의 문제가 있다. 역최적화가 일어나거나 불필요한 코드까지 최적화하는 문제
최적화없어서 빠르고, AST 분석도 하지 않고 바이트코드를 컴파일한다.

## 인라이닝

엔진이 함수인라이닝 최적화함

```jsx
생각보다 개발자 입장에서 가독성만을 위한 코드를 짜도 엔진이 알아서 최적화 해주는 부분도 생각해야 할 것 같다. 최적화를 위해 과도한 인라이닝을 소스코드에 한다면 가독성을 해치면서 어차피 엔진에서 해주는 부분이기에 불필요할 수 있는 것 처럼`
```

## 히든클래스

최적화에 사용
[[]] 개발자가 접근하지 못하는 프로퍼티 속성 기존: [[value]]
히든클래스의 프로퍼티 속성은 메모리 오프셋을 갖고있다. value가 아닌,
같은 구조의 객체가 아무리 생겨도 같은 히든클래스를 공유한다.

단, 빈객체 생성 후에 프로퍼티를 동적으로 추가하는 경우는 다르다.
빈 객체를 빈 히든클래스를 가리킨다.
프로퍼티가 추가될 때 새로운 히든클래스가 생성되면서 객체가 신규 히든클래스를 가리킨다.
기존의 빈 히든클래스는 트랜지션이라는 속성으로 새로운 히든클래스를 가리킨다.

이렇게 쭉 연결될 히든클래스는 트랜지션 체인이 됨
트랜지션 체인을 거슬러 모든 프로퍼티에 접근하게 된다.

## 인라인 캐싱

객체 접근이 반복호출될경우 인 인라인캐싱상태, 오프셋, 히든클래스id 의 슬롯을 저장한다.
히든클래스를 비교하는 캐싱.

캐싱상태: 초기화, 모놀로픽, 폴리모픽, 메가모픽(5개 다른 속성)
모노모픽 인라인캐싱을 유지할 수록 좋다!
 - 동일한 히든클래스 유지하도록 하자!
 - 동일한 순서로 객체를 생성하자!

## 정리

- 특별한 이유가 없다면 객체는 한번에 선언하자.
- 같은 프로퍼티들을 가졌다면 순서를 동일하게하자!
- 동적 할당시에도 프로퍼티 순서를 맞추면 유리하다!(히든클래스 결국 하나)
- 생성자가 다르면(Obejct vs constructor) 히든클래스도 다르다.
    - 같은 클래스의 인스턴스는(속성이 전부 같다면) 히든클래스도 하나다
- value의 데이터타입이 달라도 같은 히든클래스를 가진다.(어차피 offset을 가지는거고 실제 값은 안중요)
- Node로 v8내장함수로 확인가능
- 동적할당, 동적해제 지양하면 됨.
- 생성자 속성 선언
- 함수 호출 시 동일한 객체유형 사용하기