## 4.4 병렬 커넥션

Http는 클라이언트가 여러개의 커넥션을 맺음으로써 여러 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다. (여러 개의 서버와 맺어질 수 있어야 한다.)

---

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

이미지들을 병렬로 내려받아 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어든다.

---

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

클라이언트 네트워크 대역폭이 좁을 때, 성능상의 장점은 거의 없어진다.
대부분 시간을 데이터 전송하는 데에 쓰일 것이다.

(여러 커넥션 생성하면서 생기는 부하 때문에도 오래 걸릴 수 있다.)

> 브라우저는 실제로 적은 수의 병렬(대부분 4개) 커넥션만을 허용한다.

서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어지면 임의로 끊을 수 있다.

---

### 4.4.3 병렬 커넥션은 더 빠르지 '느껴질' 수 있다.

---

## 4.5 지속 커넥션

HTTP / 1.1 을 지원하는 기기는 처리 완료 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.

이 때의 TCP 커넥션을 지속커넥션 이라고 부른다.

---

### 4.5.1 지속 커넥션 vs 병렬 커넥션

병렬 커넥션의 단점

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭 소요된다.
- 각각 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수엔 제한이 있다.

지속 커넥션의 장점

- 사전 작업과 지연을 줄임.
- 튜닝된 커넥션 유지
- 커넥션 수 줄임

애플리케이션은 적은 수의 병렬 커넥션만을 맺고 유지한다.

- HTTP/1.0+ keep-alive
- HTTP/1.1 '지속'

---

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

![[Pasted image 20220821155655.png]]

---

### 4.5.3 Keep-Alive 동작

HTTP/1.1에선 빠졌지만 아직 널리 사용되고 있기 때문에 그것을 처리할 수 있게 개발해야한다.

커넥션 유지를 위해 Connection: Keep-Alive 헤더를 포함시킨다.
요청을 받은 서버는 다음 요청도 이 커넥션을 통해 받고 싶으면 같은 헤더를 응답에 포함시킨다.

---

### 4.5.4 Keep-Alive 옵션

Connection: Keep-Alive 옵션이 있어야 사용가능
Keep-Alive: max = 5, timeout = 120

이 헤더와 옵션들은 반드시 그대로 동작한다는 보장없이 그대로 동작하길 바라는 정보.

---

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- HTTP/1.0에서 기본으로 사용되지 않아서 사용하려면 Connection: Keep-Alive 요청 헤더를 보내야 한다.
- 커넥션을 계속 유지하려면 모든 메시디에 Connection: Keep-Alive 헤더를 포함해야 한다. 그렇지 않으면 서버는 요청을 처리한 후 커넥션을 끊을 것이다.
- 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다.
- 커넥션이 끊어지기 전에 엔터티 본문 길이를 알 수 있어야 커넥션 유지가 가능하다. 정확한 Content-Length 값과 함께 멀티파트 미디어 형식, 청크 전송 인코딩으로 인코드 되어야한다는 것을 뜻함. keep-alive에서 잘못된 content-length 값을 보내는 것은 좋지 않다.
- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야한다. 프락시와 게이트웨이는 메시지들 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다.
- 정석대로면 keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 서버와 맺어지면 안된다. 멍청한 프락시로 인해 발생할 문제를 예방하기 위한 것이다.
- HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드는 무시해야한다.
- 클라이언트는 응답 전체를 받기전에 커넥션이 끊어졌을 경우 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

---

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

프락시는 Connecrtion 헤더를 이해하지 못하고 그대로 다음 프락시에 전달한다.

하지만 Connection 헤더는 홉별 헤더(hop-by-hop) 라서 한 개의 전송 링크에만 적용되며 다음 서버로 전달되어서는 안되는 것임.

프락시는 keep-alive 를 전혀 모른채 그대로 전달하기 때문에 서버가 커넥션을 끊기를 기다린다.
이 때 재요청이 들어오면 문제상황이 발생하는 것이다.

---

### 4.5.7 Proxy-Connection 살펴보기

해결책: Proxy-Connection 헤더. (모든상황에서 동작하지는 않음)

프락시가 keep-alive 를 이해할 수 있게 하는 헤더.

이 방식은 클라이언트와 서버 사이에 한 개의 프락시가 있는 경우에만 동작한다.
(proxy-connection 헤더를 connection으로 바꿔서 전송 하기 때문에 다음 프락시는 또 이해하지 못하게 될 것이라 그런 듯)

---

### 4.5.8 HTTP/1.1의 지속 커넥션

keep-alive 대신 더 개선된 지속 커넥션을 지원한다.
목적은 같다.

1.1의 지속 커넥션은 기본적으로 활성화 되어 있고 트랜잭션이 끝 난 다음 Connection: close 헤더를 명시해야 끊을 수 있다.

---

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트는 Connection: close 헤더를 포함 했으면 추가요청을 보낼 수 없다.
- 추가요청을 보내지 않을 것이라면 Connection: close 헤더를 포함해야한다.
- 모든 메시지가 자신의 길이를 정확히 가지고 있어야 지속시킬 수 있다.
  (정확한 content-length 값, 청크 전송 인코딩)
- http/1.1 프락시는 클라이언트와 서버 각각에 별도 지속 커넥션을 맺고 관리해야한다.
- http/1.1 프락시 서버는 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않으면 지속 커넥션을 맺으면 안되지만, 현실적으로 쉽지않다.
- http/1.1 애플리케이션은 끊어지는 커넥션을 복구할 수 있어야한다. 가능한한 다시 보내야 한다.
- 클라이언트는 전체 응답 받기 전에 커넥션이 끊어지면 요청을 반복해서 보낼 준비가 되어 있어야 한다.
- 하나의 클라이언트는 서버 과부하 방지를 위해 넉넉 잡아 두 개의 지속커넥션만을 유지해야한다.
- 프락시는 서버나 상위 프락시에 넉넉잡아 2N(사용자수)의 커넥션을 유지해야 한다.
