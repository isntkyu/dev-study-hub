# 컴퓨터 밑바닥의 비밀

## 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

인간은 추상적인 표현에 익숙하다!  
프로그래밍언어는 구문트리가 된다!(컴파일러)  
CPU별 동작을 표준명령어로 해석하는 가상머신!(인터프리터)  
- c/cpp는 직접 기계어로 번역하여 CPU로 넘기고
- 자바는 바이트코드로 변환한 후 가상머친으로 넘겨 실행한다.

### 컴파일러

컴파일러는 고수준을 저수준으로 번역한다. 소스파일(문자열)을 실행파일(기계어)로.  
어휘분석: 컴파일러가 소스파일에서 토큰을 추출하는 과정.  
구문분석: 토큰 해석을 통해 문법오류를 찾아내며, 구조를 구문트리로 만든다.  
의미분석: 구문트리에 이상이 없는지 확인(예를 들면, 부등호 양쪽이 같은 자료형인지)  
중간코드 생성(IR code)  
어셈블리어 코드 생성 후 기계어로 변환

### 링커

컴파일러가 생성한 대상파일 (Ex) *.o 확장자) 를 묶어 하나의 최종 실행파일을 생성한다.  
다른 대상파일에 종속성이 있을 때 링커가 메모리 주소를 연결해주는 재배치를 실행한다. 

정적 라이브러리는 미리 컴파일되어 그대로 복제되어 링킹된다.  
동적 라이브러리는 참조된 필수 정보만 실행 파일에 링킹된다. (실행파일크기가 줄어듦) 런타임 동적 링크도 가능하다. (플러그인)  
c언어의 prinf() 같은 것도 동적 라이브러리에 있는거다(표준 라이브러리)

### 가상메모리

가상 메모리와 물리 메모리 매핑이 되어있고, 각 프로그램은 가상메모리를 바라보고, 동작한다.  
가상메모리 덕에 링커가 효율적으로 동작할 수 있다.  
가상메모리는 표준화 되어있고 크기가 동일하다.  
프로세스 별로 가상메모리 매핑관계를 담고 있는 페이지 테이블이 있다.  
> 프로세스가 같은 가상메모리 주소를 바라보아도 실제 물리주소는 다르기 때문에 문제가 없고, 같은 가상메모리 주소를 사용하기 때문에 링커가 메모리 주소를 미리알 수 있어, 효율적으로 동작할 수 있음.

### 추상화

추상화 관계
- 입출력 > 파일
- 실행중인 프로그램 > 프로세스
- 물리메모리와 파일 > 가상메모리
- 프로세스와 프로세스 종속적인 환경 > 컨테이너
- 네트워크 프로그래밍 > 소켓
- CPU, 운영체제, 응용프로그램 > 가상 머신


## 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

### 운영체제, 프로세스, 스레드의 근본 이해하기

CPU는 프로세스가 뭔지 스레드가 뭔지 운영체제가 뭔지 알지 못한다.  
그저 메모리에서 명령어를 가져와서 실행하고, 다음 명령어를 가져오고를 반복한다.  

그렇다면 CPU가 어떤 기준으로 명령어를 가져올까?  
**PC(program couter) 레지스터**가 명령어 주소를 저장하고 있다.

즉, 프로그램을 실행하면, 실행파일을 메모리에 적재(Loader)한 후 첫 번째 명령어(main 함수)의 주소를 PC 레지스터에 적재하면 되는 것이다.

CPU 멀티태스킹을 위해, 하나의 작업의 상태 정보를 저장해야 하는데, 이 상태를 **Context**라고 한다.  
Context(상황 정보)를 포함하여 프로그램에 필요한 정보에 대한 구조체(객체)를 **Process**라고 한다.  
모든 프로그램은 프로세스 형태로 관리된다.

프로그램을 자동으로 적재해 주는 적재도구와 멀티태스킹을 실현해주는 프로세스 관리 도구등을 모아둔 도구를 **운영체제(OS)** 라고 한다.

프로세스 주소 공간(Process address space)의 영역 (Segment)
- 코드영역(기계어)
- 데이터 영역(전역변수)
- 힙 영역(malloc이 반환한 메모리)
- 스택 영역(함수의 실행 시간 스택)

동시 실행을 위해 멀티프로페스 프로그래밍이 필요하다. 그런데 프로세스간 통신을 구현하기엔 복잡하다.  
하나의 프로세스 주소 공간을 여러 CPU가 공유하게하고, 각 CPU의 PC레지스터에 다른 진입함수 주소를 주면  
프로세스간 통신 없이 동시작업이 가능하다.  
이렇게 하나의 프로세스에 여러개 실행가능한 실행 흐름을 **스레드(thread)** 라고 한다.

스레드는 운영체제 계층에서 구현되어 코어 개수와는 무관하다.  
CPU가 기계어를 실행할 때도 실행 중인 명령어가 어느 스레드인지 모른다.  
CPU는 스레드를 고려해서 실행하지 않기 때문에 다중 스레드 공유 리소스 문제가 생기며,  
프로그래머가 상호배제와 동기화를 이용하여 명시적으로 해결해야 한다.

### 다중 스레드와 스레드 풀

다중 스레드에서 스레드는 프로세스 주소 공간에 각자 자신의 스택영역을 가지고, 스레드는 그것을 인지하고 있다.

스레드를 너무 많이 생성하면 
1. 스레드 생성 종료에 시간 낭비
2. 각자의 스택 영역을 만들어야 하는 공간 낭비
3. 스레드 전환 비용 부담  

그래서 **스레드 풀**이 탄생했다.

스레드 풀은 단지 스레드 여러 개를 미리 생성해놓고 재사용 하는 것이다.  
그럼 작업을 어떻게 스레드 풀 내의 스레드에 전달할까?  
이 때 **작업 대기열(TaskQueue)** 를 사용한다. (Produce - Consume)

### 스레드 간 공유되는 프로세스 리소스

스레드간 공유되는 리소스는, 스레드 전용 공간인 스택 영역을 제외하고 나머지 프로세스 주소 공간 영역을 뜻한다.  
다른 스레드에서 접근 불가능한 전용 스택영역과 PC레지스터, 스택 포인터 등을 **스레드 상황정보(ThreadContext)** 라고 한다.

스레드 위험성 문제
- 코드영역: 읽기 전용이라 스레드 위험성이 없다.
- 데이터 영역: 스레드가 전역 변수를 수정할 위험이 있다.
- 힙 영역: 힙 영역에 존재하는 메모리의 포인터를 스레드가 안다면 접근이 가능하다.
- 스택 영역: 스레드 고유의 실행 프레임이지만, 결국 하나의 프로세스 주소 공간에 있기 때문에 다른 스레드의 포인터만 획득하면 다른 스레드의 데이터 접근 가능. 스택 영역을 보호하는 별도 작동은 없음.
- 동적 링크 라이브러리 공간도 공유 리소스
- 프로세스가 연 파일 정보도 공유 리소스

스레드 전용 저장소를 활용할 수도 있다. 변수 인스턴스가 스레드에 각각 떠서 영향을 주지 않음.

### 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있다.  
공유 리소스를 사용하는 스레드가 스레드 안전을 달성하려면 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞춰서 공유 리소스를 사용해야 한다.

- 무상태 함수는 스레드 안전이다. (포인터를 공유받으면 안됨)
- 전용 리소스만 사용하면 스레드 안전이다.
- 데이터 영역, 힙영역을 수정하지 않아야함.
- 접근해야하면 lock 이나 세마포어 활용, 전역 변수 수정은 아토믹 하게(원자적 연산)
- 주소를 return 하지 않는다. (싱글톤 패턴은 예외)

동기화시 상호배제 (뮤텍스, 스핀잠금, 세마포어)
> 스레드 안전 구현은 스레드 전용 리소스와 스레드 공유 리소스를 중심으로 진행한다.

지금까지 스레드는 커널 스레드를 의미했다. 스레드 라이프사이클을 프로그래머가 아닌 운영체제가 관여한다.  
OS에 의존하지 않고 스레드를 구현하려면 **코루틴** 으로 구현할 수 있다.

### 코루틴은 어떻게 구현될까?

코루틴은 일시 중지 되거나(yield) 다시 시작할 수 있기에, 상태정보를 기록해야한다.  
일반 함수는 레지스터나 함수실행시 상태를 스택영역에 보관한다.  
하지만, 코루틴은 힙영역 메모리를 사용한다.

이론적으로 하나의 스레드에서 여러 실행흐름을 만들 수 있는 것이고 운영체제의 개입도 필요없다.

### 콜백함수

매개변수로 전달되는 실행 가능한 코드

> 논블로킹이 반드기 비동기를 의미하진 않는 이유는?  
> 스레드가 중지되지 않아도, A가 하던 일을 하지 않고, B 함수의 완료를 확인하는 작업만 진행한다면 블로킹인 것

### 코루틴: 동기 방식의 비동기 프로그래밍

코루틴이 일시중지 되어도 작업자 스레드가 블로킹 되지 않는 다는 것이 큰 차이다.

#### 정리
- 코루틴: 어떤 함수가 CPU를 능동적으로 일시 중지하고 다음에 함수가 다시 호출될 때, 앞서 중단된 지점에서 계속 실행하는 것이 가능할 때 이 함수가 코루틴에 해당한다.
- 스레드: 함수의 일시 중지와 재개가 커널 상태에서 구현되는 경우를 스레드라고 한다.
- 프로세스: 스레드에 주소 공간처럼 종속된 실행시 리소스를 결합한 것이 프로세스
- 클로저: 함수의 실행시간 환경까지 묶인 코드
- 컨테이너: 프로그램이 의존하는 실행 환경과 함께 묵인 것

---

## 메모리

### 메모리의 본질

메모리셀: 1비트가 보관되는 공간(0,1)  
CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 할 수 있다. (그래서 메모리에 값을 올려야됨.)

### 프로세스 안에서 메모리는 어떤 모습일까?

페이지 테이블: 가상메모리와 물리메모리 매핑관계 저장. 프로세스당 페이지 테이블 하나

### 스택 영역: 함수 호출은 어떻게 구현될까?

함수는 스택 프레임을 가진다. 스택프레임에는 return, jump(call)등을 위한 (제어권 이동) 정보가 있다.  
cpu제어권을 return할 장소, jump 할 장소를 갖고 있다.  
각 함수는 고유의 스택 프레임이 있다.

매개변수와 반환값은 레지스터에 저장된다.  
하지만 레지스터가 부족하다면? 스택프레임에 매개변수를 넣을 수 있다.  

지역 변수도 마찬가지다.

레지스터를 사용하고나면 레지스터를 원래 초깃값으로 돌려놔야한다. 그 초깃값도 스택프레임에 넣어둔다.

이렇게 스택영역이 점점 넓어지면 유휴영역을 차지하게되는데, 여기는 동적라이브러리가 적재되는 곳  
유휴영역 아래는 힙영역 (다음은 데이터, 다음은 코드)

### 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

힙 영역: 프로그래머가 완전제어할 수 있는 큰 메모리 영역(동적 할당용)  
new / malloc / free / delete

힙영역의 메모리 조각들은 연결리스트를 형성하고 머리정보를 통해 다음 노드와 할당 상태, 공간크기를 안다. < 복습 각 

여유 공간을 찾는 알고리즘
- first fit: 첫번쨰로 찾아낸 공간
- 커누스 모리스 프랫 알고리즘: 마지막으로 발견한 위치에서 여유공간을 찾기 시작. (first fit만 못하다는 것이 밝혀짐)
- best fit: 전부 찾은 후 가장 최적의 조각을 반환

메모리 해제를 효율적으로 하기 위해 꼬리정보(footer)가 고안됐다. 연결 리스트를 효과적으로 재병합하기 위해.

### 메모리를 할당할 때 저수준 계층에서 일어나는 일

커널 상태: 가장 cpu의 특권이 강한 상태. 운영체제를 실행할 때 바로 커널상태임

사용자 상태: 특권이 가장 약한 응용프로그램단계. 코드를 실행할 때

시스템 호출: 사용자 상태에서 운영체제를 동작시키는 방법

즉, 프로세스는 클라이언트이고 운영체제는 서버인 셈이다.

표준라이브러리: C언어에서 시스템 호출을 래핑한 것이라는 말인 듯 (malloc등을 담고 있음)


brk  

힙영역의 top을 가리키는 변수다.  
힙 영역이 부족할 때 (malloc) brk를 위로 이동하는 시스템 호출을 한다.  
*(brk를 호출하면 CPU가 커널상태로 전환되는 것이다.)*  
메모리가 부족할 때, 여유 메모리 조각을 찾는 동작이다. (mmap 시스템 호출도 같은 목적으로 사용 가능)

가상 메모리를 지원하는 시스템에서는 위 과정이 물리적으로 일어나는 것은 아니고,  
실제 메모리는 사용되는 순간 할당된다.

> 가상메모리와 물리메모리가 연결되어있지 않으면 페이지 누락 오류가 발생하고 운영체제는 이를 감지하여,  
CPU가 커널 상태가 되고, 메모리를 매핑한 뒤 다시 사용자 상태가 된다.

### 고성능 서버의 메모리 풀은 어떻게 구현될까?

메모리 풀: malloc을 사용하는 대신 응용 프로그램에서 자체적으로 메모리 할당 전략을 구현하는 방법 (malloc은 범용 메모리 할당자)

한 번에 큰 메모리 조각을 요청하고 자체적으로 메모리 할당/해제를 관리하는 원리이다.  

메모리 해제를 그 때 그 때 수행하지 않고, 특정 상황마다 한 번에 몰아서 해제함으로써 성능을 챙긴다!

### 왜 SSD는 메모리로 사용할 수 없을까 ?

1. 10분의 1 정도 수준으로 느리다.
2. 메모리 단위가 다르다.(바이트 단위를 지원 안함)
3. CPU가 SSD를 접근할 수 없다.