# 컴퓨터 밑바닥의 비밀

## 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

인간은 추상적인 표현에 익숙하다!  
프로그래밍언어는 구문트리가 된다!(컴파일러)  
CPU별 동작을 표준명령어로 해석하는 가상머신!(인터프리터)  
- c/cpp는 직접 기계어로 번역하여 CPU로 넘기고
- 자바는 바이트코드로 변환한 후 가상머친으로 넘겨 실행한다.

### 컴파일러

컴파일러는 고수준을 저수준으로 번역한다. 소스파일(문자열)을 실행파일(기계어)로.  
어휘분석: 컴파일러가 소스파일에서 토큰을 추출하는 과정.  
구문분석: 토큰 해석을 통해 문법오류를 찾아내며, 구조를 구문트리로 만든다.  
의미분석: 구문트리에 이상이 없는지 확인(예를 들면, 부등호 양쪽이 같은 자료형인지)  
중간코드 생성(IR code)  
어셈블리어 코드 생성 후 기계어로 변환

### 링커

컴파일러가 생성한 대상파일 (Ex) *.o 확장자) 를 묶어 하나의 최종 실행파일을 생성한다.  
다른 대상파일에 종속성이 있을 때 링커가 메모리 주소를 연결해주는 재배치를 실행한다. 

정적 라이브러리는 미리 컴파일되어 그대로 복제되어 링킹된다.  
동적 라이브러리는 참조된 필수 정보만 실행 파일에 링킹된다. (실행파일크기가 줄어듦) 런타임 동적 링크도 가능하다. (플러그인)  
c언어의 prinf() 같은 것도 동적 라이브러리에 있는거다(표준 라이브러리)

### 가상메모리

가상 메모리와 물리 메모리 매핑이 되어있고, 각 프로그램은 가상메모리를 바라보고, 동작한다.  
가상메모리 덕에 링커가 효율적으로 동작할 수 있다.  
가상메모리는 표준화 되어있고 크기가 동일하다.  
프로세스 별로 가상메모리 매핑관계를 담고 있는 페이지 테이블이 있다.  
> 프로세스가 같은 가상메모리 주소를 바라보아도 실제 물리주소는 다르기 때문에 문제가 없고, 같은 가상메모리 주소를 사용하기 때문에 링커가 메모리 주소를 미리알 수 있어, 효율적으로 동작할 수 있음.

### 추상화

추상화 관계
- 입출력 > 파일
- 실행중인 프로그램 > 프로세스
- 물리메모리와 파일 > 가상메모리
- 프로세스와 프로세스 종속적인 환경 > 컨테이너
- 네트워크 프로그래밍 > 소켓
- CPU, 운영체제, 응용프로그램 > 가상 머신


## 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

### 운영체제, 프로세스, 스레드의 근본 이해하기

CPU는 프로세스가 뭔지 스레드가 뭔지 운영체제가 뭔지 알지 못한다.  
그저 메모리에서 명령어를 가져와서 실행하고, 다음 명령어를 가져오고를 반복한다.  

그렇다면 CPU가 어떤 기준으로 명령어를 가져올까?  
**PC(program couter) 레지스터**가 명령어 주소를 저장하고 있다.

즉, 프로그램을 실행하면, 실행파일을 메모리에 적재(Loader)한 후 첫 번째 명령어(main 함수)의 주소를 PC 레지스터에 적재하면 되는 것이다.

CPU 멀티태스킹을 위해, 하나의 작업의 상태 정보를 저장해야 하는데, 이 상태를 **Context**라고 한다.  
Context(상황 정보)를 포함하여 프로그램에 필요한 정보에 대한 구조체(객체)를 **Process**라고 한다.  
모든 프로그램은 프로세스 형태로 관리된다.

프로그램을 자동으로 적재해 주는 적재도구와 멀티태스킹을 실현해주는 프로세스 관리 도구등을 모아둔 도구를 **운영체제(OS)** 라고 한다.

프로세스 주소 공간(Process address space)의 영역 (Segment)
- 코드영역(기계어)
- 데이터 영역(전역변수)
- 힙 영역(malloc이 반환한 메모리)
- 스택 영역(함수의 실행 시간 스택)

동시 실행을 위해 멀티프로페스 프로그래밍이 필요하다. 그런데 프로세스간 통신을 구현하기엔 복잡하다.  
하나의 프로세스 주소 공간을 여러 CPU가 공유하게하고, 각 CPU의 PC레지스터에 다른 진입함수 주소를 주면  
프로세스간 통신 없이 동시작업이 가능하다.  
이렇게 하나의 프로세스에 여러개 실행가능한 실행 흐름을 **스레드(thread)** 라고 한다.

스레드는 운영체제 계층에서 구현되어 코어 개수와는 무관하다.  
CPU가 기계어를 실행할 때도 실행 중인 명령어가 어느 스레드인지 모른다.  
CPU는 스레드를 고려해서 실행하지 않기 때문에 다중 스레드 공유 리소스 문제가 생기며,  
프로그래머가 상호배제와 동기화를 이용하여 명시적으로 해결해야 한다.

### 다중 스레드와 스레드 풀

다중 스레드에서 스레드는 프로세스 주소 공간에 각자 자신의 스택영역을 가지고, 스레드는 그것을 인지하고 있다.

스레드를 너무 많이 생성하면 
1. 스레드 생성 종료에 시간 낭비
2. 각자의 스택 영역을 만들어야 하는 공간 낭비
3. 스레드 전환 비용 부담  

그래서 **스레드 풀**이 탄생했다.

스레드 풀은 단지 스레드 여러 개를 미리 생성해놓고 재사용 하는 것이다.  
그럼 작업을 어떻게 스레드 풀 내의 스레드에 전달할까?  
이 때 **작업 대기열(TaskQueue)** 를 사용한다. (Produce - Consume)

### 스레드 간 공유되는 프로세스 리소스

스레드간 공유되는 리소스는, 스레드 전용 공간인 스택 영역을 제외하고 나머지 프로세스 주소 공간 영역을 뜻한다.  
다른 스레드에서 접근 불가능한 전용 스택영역과 PC레지스터, 스택 포인터 등을 **스레드 상황정보(ThreadContext)** 라고 한다.

스레드 위험성 문제
- 코드영역: 읽기 전용이라 스레드 위험성이 없다.
- 데이터 영역: 스레드가 전역 변수를 수정할 위험이 있다.
- 힙 영역: 힙 영역에 존재하는 메모리의 포인터를 스레드가 안다면 접근이 가능하다.
- 스택 영역: 스레드 고유의 실행 프레임이지만, 결국 하나의 프로세스 주소 공간에 있기 때문에 다른 스레드의 포인터만 획득하면 다른 스레드의 데이터 접근 가능. 스택 영역을 보호하는 별도 작동은 없음.
- 동적 링크 라이브러리 공간도 공유 리소스
- 프로세스가 연 파일 정보도 공유 리소스

스레드 전용 저장소를 활용할 수도 있다. 변수 인스턴스가 스레드에 각각 떠서 영향을 주지 않음.

### 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있다.  
공유 리소스를 사용하는 스레드가 스레드 안전을 달성하려면 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞춰서 공유 리소스를 사용해야 한다.

- 무상태 함수는 스레드 안전이다. (포인터를 공유받으면 안됨)
- 전용 리소스만 사용하면 스레드 안전이다.
- 데이터 영역, 힙영역을 수정하지 않아야함.
- 접근해야하면 lock 이나 세마포어 활용, 전역 변수 수정은 아토믹 하게(원자적 연산)
- 주소를 return 하지 않는다. (싱글톤 패턴은 예외)

동기화시 상호배제 (뮤텍스, 스핀잠금, 세마포어)
> 스레드 안전 구현은 스레드 전용 리소스와 스레드 공유 리소스를 중심으로 진행한다.

지금까지 스레드는 커널 스레드를 의미했다. 스레드 라이프사이클을 프로그래머가 아닌 운영체제가 관여한다.  
OS에 의존하지 않고 스레드를 구현하려면 **코루틴** 으로 구현할 수 있다.

### 코루틴은 어떻게 구현될까?

코루틴은 일시 중지 되거나(yield) 다시 시작할 수 있기에, 상태정보를 기록해야한다.  
일반 함수는 레지스터나 함수실행시 상태를 스택영역에 보관한다.  
하지만, 코루틴은 힙영역 메모리를 사용한다.

이론적으로 하나의 스레드에서 여러 실행흐름을 만들 수 있는 것이고 운영체제의 개입도 필요없다.

### 콜백함수

매개변수로 전달되는 실행 가능한 코드

> 논블로킹이 반드기 비동기를 의미하진 않는 이유는?  
> 스레드가 중지되지 않아도, A가 하던 일을 하지 않고, B 함수의 완료를 확인하는 작업만 진행한다면 블로킹인 것

### 코루틴: 동기 방식의 비동기 프로그래밍

코루틴이 일시중지 되어도 작업자 스레드가 블로킹 되지 않는 다는 것이 큰 차이다.

#### 정리
- 코루틴: 어떤 함수가 CPU를 능동적으로 일시 중지하고 다음에 함수가 다시 호출될 때, 앞서 중단된 지점에서 계속 실행하는 것이 가능할 때 이 함수가 코루틴에 해당한다.
- 스레드: 함수의 일시 중지와 재개가 커널 상태에서 구현되는 경우를 스레드라고 한다.
- 프로세스: 스레드에 주소 공간처럼 종속된 실행시 리소스를 결합한 것이 프로세스
- 클로저: 함수의 실행시간 환경까지 묶인 코드
- 컨테이너: 프로그램이 의존하는 실행 환경과 함께 묵인 것

---

## 메모리

### 메모리의 본질

메모리셀: 1비트가 보관되는 공간(0,1)  
CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 할 수 있다. (그래서 메모리에 값을 올려야됨.)

### 프로세스 안에서 메모리는 어떤 모습일까?

페이지 테이블: 가상메모리와 물리메모리 매핑관계 저장. 프로세스당 페이지 테이블 하나

### 스택 영역: 함수 호출은 어떻게 구현될까?

함수는 스택 프레임을 가진다. 스택프레임에는 return, jump(call)등을 위한 (제어권 이동) 정보가 있다.  
cpu제어권을 return할 장소, jump 할 장소를 갖고 있다.  
각 함수는 고유의 스택 프레임이 있다.

매개변수와 반환값은 레지스터에 저장된다.  
하지만 레지스터가 부족하다면? 스택프레임에 매개변수를 넣을 수 있다.  

지역 변수도 마찬가지다.

레지스터를 사용하고나면 레지스터를 원래 초깃값으로 돌려놔야한다. 그 초깃값도 스택프레임에 넣어둔다.

이렇게 스택영역이 점점 넓어지면 유휴영역을 차지하게되는데, 여기는 동적라이브러리가 적재되는 곳  
유휴영역 아래는 힙영역 (다음은 데이터, 다음은 코드)

### 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

힙 영역: 프로그래머가 완전제어할 수 있는 큰 메모리 영역(동적 할당용)  
new / malloc / free / delete

힙영역의 메모리 조각들은 연결리스트를 형성하고 머리정보를 통해 다음 노드와 할당 상태, 공간크기를 안다. < 복습 각 

여유 공간을 찾는 알고리즘
- first fit: 첫번쨰로 찾아낸 공간
- 커누스 모리스 프랫 알고리즘: 마지막으로 발견한 위치에서 여유공간을 찾기 시작. (first fit만 못하다는 것이 밝혀짐)
- best fit: 전부 찾은 후 가장 최적의 조각을 반환

메모리 해제를 효율적으로 하기 위해 꼬리정보(footer)가 고안됐다. 연결 리스트를 효과적으로 재병합하기 위해.

### 메모리를 할당할 때 저수준 계층에서 일어나는 일

커널 상태: 가장 cpu의 특권이 강한 상태. 운영체제를 실행할 때 바로 커널상태임

사용자 상태: 특권이 가장 약한 응용프로그램단계. 코드를 실행할 때

시스템 호출: 사용자 상태에서 운영체제를 동작시키는 방법

즉, 프로세스는 클라이언트이고 운영체제는 서버인 셈이다.

표준라이브러리: C언어에서 시스템 호출을 래핑한 것이라는 말인 듯 (malloc등을 담고 있음)


brk  

힙영역의 top을 가리키는 변수다.  
힙 영역이 부족할 때 (malloc) brk를 위로 이동하는 시스템 호출을 한다.  
*(brk를 호출하면 CPU가 커널상태로 전환되는 것이다.)*  
메모리가 부족할 때, 여유 메모리 조각을 찾는 동작이다. (mmap 시스템 호출도 같은 목적으로 사용 가능)

가상 메모리를 지원하는 시스템에서는 위 과정이 물리적으로 일어나는 것은 아니고,  
실제 메모리는 사용되는 순간 할당된다.

> 가상메모리와 물리메모리가 연결되어있지 않으면 페이지 누락 오류가 발생하고 운영체제는 이를 감지하여,  
CPU가 커널 상태가 되고, 메모리를 매핑한 뒤 다시 사용자 상태가 된다.

### 고성능 서버의 메모리 풀은 어떻게 구현될까?

메모리 풀: malloc을 사용하는 대신 응용 프로그램에서 자체적으로 메모리 할당 전략을 구현하는 방법 (malloc은 범용 메모리 할당자)

한 번에 큰 메모리 조각을 요청하고 자체적으로 메모리 할당/해제를 관리하는 원리이다.  

메모리 해제를 그 때 그 때 수행하지 않고, 특정 상황마다 한 번에 몰아서 해제함으로써 성능을 챙긴다!

### 왜 SSD는 메모리로 사용할 수 없을까 ?

1. 10분의 1 정도 수준으로 느리다.
2. 메모리 단위가 다르다.(바이트 단위를 지원 안함)
3. CPU가 SSD를 접근할 수 없다.

## 트랜지스터에서 CPU로, 이보다 더 중요한 것은 없다.

### CPU가 IF 문을 만났을 때

CPU의 명령 처리 절차는 파이프라인 이라는 기술을 통해 처리량을 높인다.  
IF가 파이프라인을 만나면, 분기예측이라는 CPU의 추측 과정을 통해 IF문이 끝나기 전에 파이프라인에 명령이 들어가고,  
예측이 틀리면 성능 손실이 발생하는 것이다.  

예시) 정렬된 배열을 탐색하는 경우 분기예측 적중률이 높아서 성능이 좋음.  

최신 CPU의 분기 예측은 매우 정확하긴 하다. perf 같은 도구로 측정 가능하다.  
프로그래밍 언어의 likely / unlikely 매크로로 컴파일러에 가능성 높은 분기를 알려줄 수도 있다.

> 자바스크립트에서는, V8엔진 등이 알아서 분기예측을 최적화 하지만, hot path를 먼저 배치하는 등의 행위로 최적화를 유도할 순 있다. (JIT 컴파일러에게)

### CPU 코어 수와 스레드 수 사이의 관계는 무엇일까 ?

스레드 수는 소프트웨어 작업 단위이고 CPU가 알 필요가 없고 운영체제가 알아야 한다.  
CPU는 PC 레지스터 주소에 따라 메모리에서 기계명령어를 실행하는 것 뿐이다.

스레드를 여러개 다룰 때 코어 수를 신경쓰진 않아도 된다. (목적이 비동기라면)

하지만 코어 수 만큼 스레드를 생성하는 일정한 선형관계를 유지하면 성능 향상시킬 수 있다.(i/o 작업이 아닌 단순 계산일 경우)    

스레드 수가 한계에 다다르면 스위칭 비용때문에 성능 저하가 생길 수 있다.

### CPU 진화론

- 복잡 명령어 집합 <-> 축소 명령어 집합
- 파이프라인
- 하이퍼스레딩 (== 하드웨어 스레드)

### CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

- 레지스터  
CPU가 메모리를 직접 읽는 속도는 매우 느리고 레지스터를 읽는 속도는 매우빠르다.  
때문에 CPU가 사용할 데이터는 임시로 레지스터로 올리는 것이다.

- 스택 포인터  
모든 함수는 스택 프레임을 가진다. 스택프레임은 로컬 변수와 매개변수등을 저장하는 독립적인 공간이다.  
스택 상단(top) 정보는 스택 하단을 가리키는 스택포인터에 저장된다. (포인터로 호출 스택을 추적)

- 명령어 주소 레지스터(Program Counter 레지스터)  
실행할 기계명령어의 주소가 들어있다. CPU는 PC 레지스터의 주소를 따라 명령어를 가져와 실행한다.  
PC 레지스터를 제어하는 것은 실행 흐름을 장악하는 것이다. (CPU가 어떤 명령어를 실행할지 결정)

- 상태 레지스터  
올림수(carry)나 overflow를 저장한다.  
CPU가 어떤 상태(커널상태인지 사용자상태인지)에서 동작하는지 저장한다.  
상태 레지스터의 이 특정 비트값을 바꾸면 상태가 전환된다.

- 상황 정보(Context)  
함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 

- 시스템 호출과 커널 상태 스택  
응용프로그램이 시스템 호출을 통해 운영체제에 서비스를 요청하고 커널상태 스택에 커널 함수가 따로 쌓임(커널상태)  
시스템 호출이 완료되면 다시 사용자 상태로 전환된다.

- 인터럽트와 인터럽트 함수 스택(실행중에 마우스이동 키보드입력 네트워크 등의 작업이 가능한 이유)  
인터럽트 처리 함수에 자체 실행시간 스택이 없으면, 커널사태 스택을 이용한다.  
ISR이라는 자체 실행시간 스택이 있는 경우가 있다.

- 스레드 전환과 커널 상태 스택  
[복습 요함]

## 작은 것으로 큰 성과 이루기, 캐시

배경: 
    레지스터 용량은 제한되어있지만 명령어와 데이터와 처리 결과 모두 메모리에 기록해야 한다.  
    CPU는 빠르고 메모리는 느리다.

메모리와 CPU 사이에 캐시계층이 있다.  
캐시는 접근 속도나 용량에 따라 L1, L2, L3 캐시로 구분된다. (L1부터 차례대로 캐시를 탐색한다.)

연속 기입 (write-through): 메모리를 갱신할 때, 캐시도 같이 갱신해서 불일치 해소  
후 기입 (write-back): 캐시가 만료될 때 캐시데이터가 수정된 적이 있다면 메모리도 갱신함 (성능은 이게 낫다.)

다중코어 CPU는 코어별로 캐시를 따로 가진다.  
따라서 캐시간 불일치 해소를 위해 캐시를 함께 갱신한다. (MESI protocol)

메모리를 디스크의 캐시로 활용할 수 있다.  
또 로컬 디스크는 원격 분산 파일 시스템의 캐시로 간주할 수 있다.  
카프카는 메모리가 원격 분산 파일 시스템의 캐시가 되는 예시이다.

### 가상 메모리와 디스크

파일을 읽고 쓸 때 메모리를 디스크의 캐시로 쓸 수 있는데 디스크는 메모리의 창고 역할을 할 수 있다.  
N개의 다중 프로세스중 일부 프로세스에서는 자주 사용하지 않는 메모리 데이터를 디스크에 기록하고 물리메모리 공간을 해제한다.  
그러면 새로운 프로세스가 N + 1 개(초과) 메모리를 요청해도 메모리를 할당 받을 수 있다.(가상 메모리)  

### 어떻게 캐시 친화적인 프로그램을 작성할까?

- 공간적 지역성(메모리 주소)과 시간적 지역성을 고려한다.  
같이 쓰이는 변수는 비슷한 메모리 공간에 배치되도록 선언하여 캐시 히트를 높일 수 있다. (변수 선언 순서를 바꿈으로써 공간적 지역성을 높이는 c언어예시)

- 콜드 데이터와 핫데이터를 분리하여 선언한다. (핫데이터는 자주 접근하는 데이터)

- 다차원 배열에서 행먼저 탐색하는지 열먼저 탐색하는지에 따라서 캐시 적중률이 매우 달라진다.

> 성능 분석 도구를 통해 캐시 적중률이 병목인 경우가 아니라면 굳이 이정도 최적화를 신경 쓸 필요는 없다.

### 캐시라인

정확히 그 데이터만 캐싱하는 것이 아니라 그 데이터 주변의 묶음까지 캐싱  
묶음은 일반적으로 64바이트이고, 캐시가 히트하지 못하면 묶음을 캐시에 저장한다.

### 캐시튕김

다중 스레드는 각자의 코어에 캐시를 가질 수 있고, 캐시 갱신 절차가 n 배가 될 수 있다.(데이터를 공유할 시)  
(한 코어가 a 변수를 쓸 때 다른 코어의 캐시의 a 변수를 무효화하는 과정을 거치게됨.)

> 캐시 라인과 캐시튕김 때문에 단일 스레드가 빠를 수 있음을 인지하자
> 함께 쓰이는 변수는 같은 캐시라인이 되도록 선언 순서도 생각해야한다. (고수준 언어는 괜찮음)

- CPU는 성능을 위해 기계어를 비순차적 실행할 수 있다.
- 저장버퍼를 통해 캐시를 비동기 갱신할 수 있다.
- 공유데이터를 사용하면 위 현상을 쉽게 볼 수 있다. (멑티스레드일 때)

### 비순차적 실행으로 발생하는 문제를 해결하기 위한 메모리 장벽

- LoadLoad 
- StoreStore
- LoadStore
- StoreLoad

### 획득- 해제 의미론 (acquire -release)

Mutex

### 잠금 프로그래밍과 잠금 없는 프로그래밍

Mutex Lock 을 획득하지 못한 스레드가 대기하거나 스핀잠금(계속 확인) 하지 않고 다른 작업을 하는 것이 잠금 없는 프로그래밍

### 요약

- 성능을 위해 CPU는 코드를 엄격하게 순서대로 실행할 필요가 없다.
- 단일 스레드인 경우는 비순차 실행을 볼 수 없다.
- 메모리 장벽의 목적은 비순차 실행으로 인한 불일치 해결
- 멀티스레드 잠금없는 프로그래밍을 사용할 필요가 없다면 명령어 재정렬을 걱정안해도 된다.

## 입출력이 없는 컴퓨터가 있을까?

### CPU는 어떻게 입출력 작업을 처리할까?

CPU와 마찬가지로 장치(device)에도 데이터를 저장하는 레지스터와 제어 정보와 상태 정보를 저장하는 레지스터가 있다.  
프로그래머 관점에서 장치는 레지스터 묶음에 불과하다.  
장치 레지스터는 기계어로 읽고 쓴다.

장치 레지스터를 어떻게 다룰까?  
- x86의 IN, OUT과 같이 특수한 기계어를 쓴다.
- 주소공간을 할당하고 메모리 명령어(LOAD, STORE)를 같이 쓰되, 특정 주소일 경우 장치 레지스터의 공간으로 사용한다. (메모리 사상 입출력)

CPU가 입력이 언제 발생할 줄 알고 LOAD 할까?  
- 폴링하기(계속 검사하기)
- 인터럽트 구동식 비동기 입출력. 인터럽트 신호를 감지하여 하던 일을 멈추고 입력을 받아온다. (이 때 실행하던 프로그램의 상태를 저장하고 복원해서 이어서 진행한다. 상태는 스택에 저장된다(후입선출복원))

CPU는 어떻게 인터럽트 신호를 감지할까?  

### 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까?

최신 컴퓨터의 경우, CPU 개입이 필요없다.  DMA가 한다.

### 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?

메모리 관점에서의 입출력은 단순한 copy 이다.  

파일을 읽을 때는 어떤 언어이던 버퍼를 정의한 후 read계열 함수를 호출한다.  
이 때 디스크는 느리기 때문에 프로세스가 Block 되는데, 운영체제는 DMA 작동 방식으로 데이터를 메모리영역으로 복사한다. 이 메모리 영역이 Buffer 이다.  
이 작업중에 CPU는 다음 프로세스(B)를 실행하다가. 복사가 완료되면 인터럽트 신호를 받은 후 프로세스A의 함수로 점프한다.  
이 때 B프로세스가 완료되지 않았다면, 다시 대기열로 들어간다.