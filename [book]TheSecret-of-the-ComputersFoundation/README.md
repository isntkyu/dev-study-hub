# 컴퓨터 밑바닥의 비밀

## 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

인간은 추상적인 표현에 익숙하다!  
프로그래밍언어는 구문트리가 된다!(컴파일러)  
CPU별 동작을 표준명령어로 해석하는 가상머신!(인터프리터)  
- c/cpp는 직접 기계어로 번역하여 CPU로 넘기고
- 자바는 바이트코드로 변환한 후 가상머친으로 넘겨 실행한다.

### 컴파일러

컴파일러는 고수준을 저수준으로 번역한다. 소스파일(문자열)을 실행파일(기계어)로.  
어휘분석: 컴파일러가 소스파일에서 토큰을 추출하는 과정.  
구문분석: 토큰 해석을 통해 문법오류를 찾아내며, 구조를 구문트리로 만든다.  
의미분석: 구문트리에 이상이 없는지 확인(예를 들면, 부등호 양쪽이 같은 자료형인지)  
중간코드 생성(IR code)  
어셈블리어 코드 생성 후 기계어로 변환

### 링커

컴파일러가 생성한 대상파일 (Ex) *.o 확장자) 를 묶어 하나의 최종 실행파일을 생성한다.  
다른 대상파일에 종속성이 있을 때 링커가 메모리 주소를 연결해주는 재배치를 실행한다. 

정적 라이브러리는 미리 컴파일되어 그대로 복제되어 링킹된다.  
동적 라이브러리는 참조된 필수 정보만 실행 파일에 링킹된다. (실행파일크기가 줄어듦) 런타임 동적 링크도 가능하다. (플러그인)  
c언어의 prinf() 같은 것도 동적 라이브러리에 있는거다(표준 라이브러리)

### 가상메모리

가상 메모리와 물리 메모리 매핑이 되어있고, 각 프로그램은 가상메모리를 바라보고, 동작한다.  
가상메모리 덕에 링커가 효율적으로 동작할 수 있다.  
가상메모리는 표준화 되어있고 크기가 동일하다.  
프로세스 별로 가상메모리 매핑관계를 담고 있는 페이지 테이블이 있다.  
> 프로세스가 같은 가상메모리 주소를 바라보아도 실제 물리주소는 다르기 때문에 문제가 없고, 같은 가상메모리 주소를 사용하기 때문에 링커가 메모리 주소를 미리알 수 있어, 효율적으로 동작할 수 있음.

### 추상화

추상화 관계
- 입출력 > 파일
- 실행중인 프로그램 > 프로세스
- 물리메모리와 파일 > 가상메모리
- 프로세스와 프로세스 종속적인 환경 > 컨테이너
- 네트워크 프로그래밍 > 소켓
- CPU, 운영체제, 응용프로그램 > 가상 머신


## 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

### 운영체제, 프로세스, 스레드의 근본 이해하기

CPU는 프로세스가 뭔지 스레드가 뭔지 운영체제가 뭔지 알지 못한다.  
그저 메모리에서 명령어를 가져와서 실행하고, 다음 명령어를 가져오고를 반복한다.  

그렇다면 CPU가 어떤 기준으로 명령어를 가져올까?  
**PC(program couter) 레지스터**가 명령어 주소를 저장하고 있다.

즉, 프로그램을 실행하면, 실행파일을 메모리에 적재(Loader)한 후 첫 번째 명령어(main 함수)의 주소를 PC 레지스터에 적재하면 되는 것이다.

CPU 멀티태스킹을 위해, 하나의 작업의 상태 정보를 저장해야 하는데, 이 상태를 **Context**라고 한다.  
Context(상황 정보)를 포함하여 프로그램에 필요한 정보에 대한 구조체(객체)를 **Process**라고 한다.  
모든 프로그램은 프로세스 형태로 관리된다.

프로그램을 자동으로 적재해 주는 적재도구와 멀티태스킹을 실현해주는 프로세스 관리 도구등을 모아둔 도구를 **운영체제(OS)** 라고 한다.

프로세스 주소 공간(Process address space)의 영역 (Segment)
- 코드영역(기계어)
- 데이터 영역(전역변수)
- 힙 영역(malloc이 반환한 메모리)
- 스택 영역(함수의 실행 시간 스택)

동시 실행을 위해 멀티프로페스 프로그래밍이 필요하다. 그런데 프로세스간 통신을 구현하기엔 복잡하다.  
하나의 프로세스 주소 공간을 여러 CPU가 공유하게하고, 각 CPU의 PC레지스터에 다른 진입함수 주소를 주면  
프로세스간 통신 없이 동시작업이 가능하다.  
이렇게 하나의 프로세스에 여러개 실행가능한 실행 흐름을 **스레드(thread)** 라고 한다.

스레드는 운영체제 계층에서 구현되어 코어 개수와는 무관하다.  
CPU가 기계어를 실행할 때도 실행 중인 명령어가 어느 스레드인지 모른다.  
CPU는 스레드를 고려해서 실행하지 않기 때문에 다중 스레드 공유 리소스 문제가 생기며,  
프로그래머가 상호배제와 동기화를 이용하여 명시적으로 해결해야 한다.

### 다중 스레드와 스레드 풀

다중 스레드에서 스레드는 프로세스 주소 공간에 각자 자신의 스택영역을 가지고, 스레드는 그것을 인지하고 있다.

스레드를 너무 많이 생성하면 
1. 스레드 생성 종료에 시간 낭비
2. 각자의 스택 영역을 만들어야 하는 공간 낭비
3. 스레드 전환 비용 부담  

그래서 **스레드 풀**이 탄생했다.

스레드 풀은 단지 스레드 여러 개를 미리 생성해놓고 재사용 하는 것이다.  
그럼 작업을 어떻게 스레드 풀 내의 스레드에 전달할까?  
이 때 **작업 대기열(TaskQueue)** 를 사용한다. (Produce - Consume)

### 스레드 간 공유되는 프로세스 리소스

스레드간 공유되는 리소스는, 스레드 전용 공간인 스택 영역을 제외하고 나머지 프로세스 주소 공간 영역을 뜻한다.  
다른 스레드에서 접근 불가능한 전용 스택영역과 PC레지스터, 스택 포인터 등을 **스레드 상황정보(ThreadContext)** 라고 한다.

스레드 위험성 문제
- 코드영역: 읽기 전용이라 스레드 위험성이 없다.
- 데이터 영역: 스레드가 전역 변수를 수정할 위험이 있다.
- 힙 영역: 힙 영역에 존재하는 메모리의 포인터를 스레드가 안다면 접근이 가능하다.
- 스택 영역: 스레드 고유의 실행 프레임이지만, 결국 하나의 프로세스 주소 공간에 있기 때문에 다른 스레드의 포인터만 획득하면 다른 스레드의 데이터 접근 가능. 스택 영역을 보호하는 별도 작동은 없음.
- 동적 링크 라이브러리 공간도 공유 리소스
- 프로세스가 연 파일 정보도 공유 리소스

스레드 전용 저장소를 활용할 수도 있다. 변수 인스턴스가 스레드에 각각 떠서 영향을 주지 않음.

### 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있다.  
공유 리소스를 사용하는 스레드가 스레드 안전을 달성하려면 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞춰서 공유 리소스를 사용해야 한다.

- 무상태 함수는 스레드 안전이다. (포인터를 공유받으면 안됨)
- 전용 리소스만 사용하면 스레드 안전이다.
- 데이터 영역, 힙영역을 수정하지 않아야함.
- 접근해야하면 lock 이나 세마포어 활용, 전역 변수 수정은 아토믹 하게(원자적 연산)
- 주소를 return 하지 않는다. (싱글톤 패턴은 예외)

동기화시 상호배제 (뮤텍스, 스핀잠금, 세마포어)
> 스레드 안전 구현은 스레드 전용 리소스와 스레드 공유 리소스를 중심으로 진행한다.

지금까지 스레드는 커널 스레드를 의미했다. 스레드 라이프사이클을 프로그래머가 아닌 운영체제가 관여한다.  
OS에 의존하지 않고 스레드를 구현하려면 **코루틴** 으로 구현할 수 있다.