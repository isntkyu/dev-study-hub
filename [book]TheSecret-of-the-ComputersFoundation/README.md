# 컴퓨터 밑바닥의 비밀

## 프로그래밍 언어부터 프로그램 실행까지, 이렇게 진행된다

인간은 추상적인 표현에 익숙하다!  
프로그래밍언어는 구문트리가 된다!(컴파일러)  
CPU별 동작을 표준명령어로 해석하는 가상머신!(인터프리터)  
- c/cpp는 직접 기계어로 번역하여 CPU로 넘기고
- 자바는 바이트코드로 변환한 후 가상머친으로 넘겨 실행한다.

### 컴파일러

컴파일러는 고수준을 저수준으로 번역한다. 소스파일(문자열)을 실행파일(기계어)로.  
어휘분석: 컴파일러가 소스파일에서 토큰을 추출하는 과정.  
구문분석: 토큰 해석을 통해 문법오류를 찾아내며, 구조를 구문트리로 만든다.  
의미분석: 구문트리에 이상이 없는지 확인(예를 들면, 부등호 양쪽이 같은 자료형인지)  
중간코드 생성(IR code)  
어셈블리어 코드 생성 후 기계어로 변환

### 링커

컴파일러가 생성한 대상파일 (Ex) *.o 확장자) 를 묶어 하나의 최종 실행파일을 생성한다.  
다른 대상파일에 종속성이 있을 때 링커가 메모리 주소를 연결해주는 재배치를 실행한다. 

정적 라이브러리는 미리 컴파일되어 그대로 복제되어 링킹된다.  
동적 라이브러리는 참조된 필수 정보만 실행 파일에 링킹된다. (실행파일크기가 줄어듦) 런타임 동적 링크도 가능하다. (플러그인)  
c언어의 prinf() 같은 것도 동적 라이브러리에 있는거다(표준 라이브러리)

### 가상메모리

가상 메모리와 물리 메모리 매핑이 되어있고, 각 프로그램은 가상메모리를 바라보고, 동작한다.  
가상메모리 덕에 링커가 효율적으로 동작할 수 있다.  
가상메모리는 표준화 되어있고 크기가 동일하다.  
프로세스 별로 가상메모리 매핑관계를 담고 있는 페이지 테이블이 있다.  
> 프로세스가 같은 가상메모리 주소를 바라보아도 실제 물리주소는 다르기 때문에 문제가 없고, 같은 가상메모리 주소를 사용하기 때문에 링커가 메모리 주소를 미리알 수 있어, 효율적으로 동작할 수 있음.

### 추상화

추상화 관계
- 입출력 > 파일
- 실행중인 프로그램 > 프로세스
- 물리메모리와 파일 > 가상메모리
- 프로세스와 프로세스 종속적인 환경 > 컨테이너
- 네트워크 프로그래밍 > 소켓
- CPU, 운영체제, 응용프로그램 > 가상 머신