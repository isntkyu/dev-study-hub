# 이벤트 기반 마이크로서비스 구축

### 🪦 툼스톤 이벤트
- 값 없이 키만 존재하는 이벤트로, 해당 데이터가 삭제되었음을 나타낸다.
- 삭제 이벤트임을 표현하는 표준적인 관례로 사용된다.

### 🧹 컴팩션 (Compaction)
- 로그에서 가장 최근 레코드만 유지하고 이전 레코드를 제거하는 방식.
- 저장 공간 최적화 및 조회 성능 향상에 기여한다.

---

### 📡 이벤트 브로커 vs 메시지 브로커

| 항목             | 메시지 브로커                        | 이벤트 브로커                          |
|------------------|--------------------------------------|----------------------------------------|
| 메시지 전달 방식 | 단일 컨슈머만 수신, ACK 후 삭제됨    | 불변 로그 기반, 여러 컨슈머가 읽기 가능 |
| 순서 보장        | 기본적으로 순서 보장 (큐 기반)       | 컨슈머 그룹 및 파티션 기반 순서 제어 가능 |
| 메시지 재사용    | 불가                                 | 가능 (오프셋 기준으로 다시 읽기 가능)   |
| 활용 예시        | SQS, RabbitMQ                        | Kafka, Pulsar                          |

> 이벤트 브로커는 오프셋 기반으로 유연하게 소비할 수 있으며, 확장성과 유실 방지 측면에서 유리하다.

---

### 🏗️ 마이크로서비스 실행 환경: 가상머신 vs 컨테이너

- **가상머신**: OS 수준 격리로 보안성이 높으나, 무겁고 느리며 비용이 많이 든다.
- **컨테이너**: 경량화된 프로세스 격리 환경으로 빠른 기동과 자원 효율성이 뛰어나 마이크로서비스에 적합하다.

---

## 📜 통신 및 데이터 규약

### ✅ 스키마 진화

- 스키마는 **정방향**, **역방향**, **양방향**으로 진화할 수 있다.
- **Avro**와 **Protocol Buffers**는 진화 전략을 잘 지원한다.
- **JSON**은 유연하지만, 스키마 진화 측면에서는 취약하다.

> 현재 JSON을 사용하고 있지만, 제로 페이로드 방식으로 PK만 포함하는 경우 진화 리스크는 낮다고 판단된다.

### ✅ 데이터 유형 전략

- 이벤트에 포함되는 데이터는 명확하게 제한해야 한다.
- 문자열 사용이나 `enum` 남용은 피해야 한다.

### ✅ 이벤트 스트림 설계 원칙

- 하나의 스트림은 **하나의 역할**만 가져야 한다.
- 이벤트에는 불필요한 필드를 넣지 않고, 결과만을 담는다.

---

## 🔄 데이터 발행 방식 비교

### 1. 쿼리 기반 동기화 (Polling)
- 주기적으로 SELECT 쿼리로 변경사항 감지
- **단점**:
  - 시스템 성능 저하
  - 삭제 감지 어려움
  - 타임스탬프 필요 (`updated_at` 기반)

### 2. CDC (Change Data Capture)
- DB의 변경 로그를 분석하여 이벤트를 발행
- **단점**:
  - 내부 데이터 모델이 외부에 노출될 가능성

### 3. 아웃박스 테이블 (Outbox Pattern)
- 내부 테이블과 아웃박스 테이블을 동일 트랜잭션으로 갱신
- 아웃박스 테이블을 읽어 이벤트 발행 후 삭제

#### 장점
- 언어/플랫폼 독립
- 스키마 강제 가능
- 내부 모델 격리
- 사전 반정규화 가능

#### 단점
- 애플리케이션 코드 변경 필요
- 비즈니스 로직에 오버헤드 발생
- 저장소 성능에 영향 가능

> 아웃박스 테이블은 데이터 포맷을 명확히 정의하여 서비스 간 결합을 줄인다.

---

## ⚙️ 이벤트 기반 처리 구성 요소

- 상태 비저장 토폴로지
  - 이벤트 변환, 분기, 병합 등
- 이벤트 스트림 리파티션
- 스트림 코파티션 (같은 파티션으로 묶음)
- 파티션 할당 방식 (컨슈머 인스턴스별 분산 처리)

---

## ⏱️ 확정적 스트림 처리와 시간 정렬

### 이벤트 스케줄링
- 여러 파티션에서 들어온 이벤트의 처리 순서를 결정하는 프로세스
- 이벤트 시간 기준으로 **인터리빙(interleaving)** 처리 가능
- 처리 기준:
  - 이벤트 시간 (추천)
  - 브로커 도착 시간
  - 컨슈머 수신 시간
  - 컨슈머 처리 시간

### 워터마크 (Watermark)
- 이벤트 시간 기준의 진행 상태를 추적
- 시간 `t` 이전 이벤트가 모두 처리되었음을 선언
- 병렬 처리 환경에서 컨슈머 간의 시간 동기화에 유용

### 스트림 시간 (Stream Time)
- Apache Kafka Streams의 개념
- 이벤트 처리 시점 중 가장 높은 타임스탬프를 유지
- 각 토폴로지마다 독립적인 스트림 시간 관리
- 하위 토폴로지에서는 한 번에 하나의 이벤트만 처리됨

> 워터마크는 선언적이며, 스트림 시간은 처리 기반으로 시간 흐름을 계산한다.

### 🌀 비순차 이벤트와 지각 이벤트 처리

- 순서가 어긋난 이벤트는 보통 여러 프로듀서와 파티션으로 인해 발생한다.
- 처리 전략:
  - 고정 윈도우
  - 슬라이딩 윈도우
  - 세션 윈도우

> 지각 이벤트에 대한 기준은 **비즈니스 요구사항에 따라 정의**되어야 하며, 절대적인 방식은 없다.

### 🔁 재처리 vs 준실시간 처리

- 오프셋 리셋 또는 이벤트 재처리 시 고려할 점:
  - 데이터 양
  - 재처리 소요 시간
  - 서비스 영향도

### 마치며

- 이벤트 기반 시스템은 **정합성과 지연의 트레이드오프**를 잘 설계해야 한다.
- 적절한 스트림 전략과 데이터 관리 정책이 안정성과 확장성에 큰 영향을 미친다.

---

## 상태 저장 스트리밍


### 상태 저장소, 이벤트 스트림에서 상태 구체화

- 구체화된 상태: (불변) 소스 이벤트 스트림의 이벤트를 투영한 것. 공통 비즈니스 엔티티
- 상태 저장소: (가변) 서비스가 비즈니스 상태를 저장하는 곳 

상태를 처리기의 내부/외부 어디에 저장할지 비즈니스에 따라 선택해야한다.

### 체인지 로그 이벤트 스트림에 상태 기록

체인지로그는 상태 저장소의 변경사항을 기록한 것이다.  
인스턴스 외부에 유지되는 영구적인 상태 사본으로써 이벤트 처리 진행을 체크포인트 하는 수단으로 활용  
최근 키/값 쌍만 알아도 상태 재구성을 할 수 있으므로 최근 데이터로 **컴팩션**이 필요하다.  
카프카 스트림즈 프레임워크는 지원한다.

### 내부 상태 저장소에 상태 구체화

동일한 컨테이너(인스턴스)에 로컬 디스크 기반 상태 저장소 활용(락스DB등의 키/값 저장소가 주로 쓰임, 관계형은 잘 안씀)  
복구나 확장에 불리하기 때문에 단순한 토폴로지에 사용하면 좋다

> NAS: 네트워크 결합 스토리지

### 외부 상태 저장소와 상태 구체화

가상머신이나 컨테이너 외부에 존재하지만 동일한 네트워크에 존재하는 상태 저장소  
완전한 데이터 지역성이 장점이나, 여러 기술을 관리해야하는 부담이 있다. (비용이나 네트워크 지연 성능저하도 있다.)

> SLA: 서비스 수준 협약 service level agreement

### 재구성 vs 상태 저장소 마이그레이션

애플리케이션의 내부 상태를 업데이트 하는 가장 일반적인 방법이 재구성(rebuild)이다.  
새로운 비즈니스 로직에 따라 상태가 재구성되고 모든 새 출력도 다운스트림으로 전파한다.

거대한 상태 저장소는 재구성이 매우 오래 걸리고 비용이 크다.  
그치만 대규모 데이터 마이그레이션의 위험성이 더 클 수 있으니 정밀한 테스트 데이터로 철저한 검증이 필요함

### 트랜잭션과 실제로 한 번 처리

카프카는 트랜잭션 지원한다.(오프셋 업데이트, 체인지 로그 업데이트, 출력 이벤트를 트랜잭션으로 묶어 원자적 처리)  
트랜잭션을 지원하지 않는 브로커를 사용해도 '실제로 한 번 처리' 로직을 구현해야한다.  
이는 '정확히 한 번 처리' 와는 다르다.

#### 실제로 한 번 처리 구현하기 (멱등성)

중복 이벤트 생성을 방지해야 한다.  
ACK를 받지 못해서 재시도를 하는 등의 컹유, 오프셋을 업데이트 하기 전에 실패하는 경우에 중복 이벤트 생성이 될 수 있음.  

## 마이크로서비스 워크플로 구축

### 코레오그래피 패턴

코레오그래피에서 프로듀서는 자신의 데이터를 누가 어떻게 소비할지 모릅니다.  
포괄적인 비즈니스와 워크플로를 구성하기 위해 재사용 가능한 서비스를 제공하는데 초점을 두었다.  
직접 API로 호출하는 마이크로서비스 보다는 결합이 느슨하다. (직접호출 MSA는 경계 컨텍스트에 완전히 종속된다.)

- 워크플로 중간 단계를 삽입하거나 순서를 바꾸면 문제가 생길 수 있음.  
- 서비스간의 관계를 콘텍스트 외부에서 이해하기 어려움.
    - 비즈니스 기능을 하나의 서비스로 로컬화하면 어느 정도 해결.

종단 간의 워크플로를 전부 다 보기 위한 모니터링이 힘들다. (이벤트 스트림의 독립성 때문에)