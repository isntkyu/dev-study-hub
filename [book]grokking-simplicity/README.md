# 쏙쏙 들어오는 함수형 코딩

<img width="101" alt="스크린샷 2024-03-10 오후 11 54 49" src="https://github.com/isntkyu/dev-study-hub/assets/56504493/13aac5f0-2941-4311-96ef-1bb6a91d8c1b">

---

- 액션

함수를 호출하는 시점과 횟수에 의존성이 있음  
부수효과가 있음

- 계산

호출 시점과 횟수가 의미 없음  
실행 전까지 동작을 알 수 없음  
순수함수

- 데이터

실행이 불가능  
이벤트로 발생한 사실

`코드를 액션, 계산 데이터로 분류하는 것이 함수형프로그래밍의 기본이며 함수형 프로그래밍에서는 액션보단 계산, 계산보단 데이터를 선호한다.`

---

`자주 바뀌는 것부터 자주 바뀌지 않는 순서로 레이어를 구성한다.`

가장 바뀌지 않는 것은 언어레벨

`비즈니스 규칙 > 도메인 규칙 > 기술스택`

- 액션에 해당하는 것

함수호출, 메서드호출, 생성자, 표현식, 상태(값 할당, 속성삭제),  
변경 가능한 값,  
암묵적 입력과 출력(= 부수효과)이 있는 함수.( <-> 명시적)

액션은 가능한 `적게, 작게 바깥쪽에`

> 리팩터링2판에서 배운 기법들이 등장한다. 모든 개발서적은 일맥상통한다 역시

- 계산 추출

암묵적 입력과 출력 찾아서 빼내기  
암묵적입력은 인자로 암묵적 출력은 리턴으로

> 연습문제를 생각해보니 바로 습득하기 좋다

- 카피온라이트

쓰기를 읽기로 바꾸는 것  
불변 데이터 구조를 읽는 것은 계산이고,  
카피온라이트는 원본을 수정하지 않기 때문에 계산이다.

객체 배열을 SLice 해도 객체들은 `구조적 공유`중이다.

- 방어적복사

원본이 바뀌는 것을 막아줌.  
데이터 전달 전 깊은복수 전달한 후 깊은복사

카피온라이트는 다른 카피온라이트 함수 호춣할때만 안전하다. 즉, 안전지대 안에서만 불변성이 보장된다.

방어적복사는 비용이 크긴함.

---

### 계층형 설계

- 계층 직접 설계

호출 그래프를 그려 코드 시각화

- 추상화 벽

라이브리나 API와 비슷하다. 클라이언트는 내부구현에 관심이 없고. 내부구현은 클라이언트의 사용처에 관심이 없다.

`배열을 순회하지 말고 객체(해시맵)을 사용하자 [성능]`

> 애초에 배열 util 함수(lodash 등)을 사용할 생각보다 객체로 구현할 생각부터 해보자!
