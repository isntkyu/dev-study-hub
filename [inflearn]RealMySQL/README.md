## ep.01 CHAR vs VARCHAR

### 공통점

- 최대 저장 가능 문자 길이를 명시하는 문자열 저장 컬럼

### 차이점

- CHAR 타입은 할당된 문자 길이와 상관없이 항상 고정된 공간을 할당해서 사용한다.
- CHAR 는 최대 255 VARCHAR는 최대 16383 글자까지 저장 가능하다
- VARCHAT 타입은 실제로 저장된 문자의 바이트 수를 별도로 관리한다. (길이 저장 바이트)
- 가변길이 문자셋(UTF8MB4)을 사용하는 경우에는 CHAR 타입도 저장된 값의 길이를 같이 관리한다.
- 공간을 미리 예약하는가 하지 않는가의 차이이다.

> 일반적으로 알려진 고정길이 값인 경우에 VARCHAR 를 사용해야 한다는 인식은 아무런 의미가 없다. (바이트 하나 정도의 차이이기 때문에)

### CHAR 사용해야할 경우

- 가변 폭이 큰 경우에 낭비가 심할 수 있다. (1~ 100 글자)
- 가변 폭이 크지 않다면 낭비는 크지 않다. (90 ~100 글자)
- 자주 변경되는 경우 (특히 인덱싱 된 컬럼)

> VARCHAR 타입은 값의 길이 변경시(update) 새로운 공간을 찾아서 저장하기에 변경이 잦아지면 컴팩션이 필요할 수 있지만, CHAR 타입 사용시엔 그러한 공간 낭비를 보완할 수 있다.

---

## ep.02 VARCHAR vs TEXT

### 공통점

- 문자열 타입
- 최대 65,535 Bytes까지 저장 가능

### 차이점

- VARCHAR는 최대 글자 수 만큼만 저장 가능
- TEXT 타입은 인덱스 생성시 Prefix 길이 지정 필요
- TEXT 타입은 표현식으로만 디폴트 값 지정 가능

> VARCHAR 타입은 메모리 버퍼 공간을 미리 할당해두며 재활용하고, TEXT 타입은 필요할 때마다 할당/해제 한다. 컬럼 사용이 빈번하다면, VARCHAR 이 권장된다.
> 반면, 길이가 긴 VARCHAR 컬럼이 자주 추가된다면, Row 최대 사이즈에 영향이 가지 않도록 TEXT 타입이 권장된다.
> VARCHAR 타입은 실제 최대 사용길이 만큼 명시해야 메모리 효율 증가

### 주의사항

저장되는 값의 사이즈가 크면 Off-page 형태로 데이터가 저장될 수 있다.
이 경우에 실제 내부 페이지에는 포인터값만 저장된다.

**Off-page 컬럼 참조여부에 따라 쿼리 성능이 매우 달라진다.**

이러한 이유 때문에 쿼리의 SELECT 절에는 가능한 필요한 컬럼만 명시해야한다.

### 정리

- 저장되는 데이터 사이즈가 크고 컬럼을 자주 사용하지 않으며, 테이블 내에 다른 문자열 컬럼이 많다면 -> TEXT
- DB 메모리 용량이 충분하고 자주 사용되며, 데이터 사이즈가 많이 크지 않다면 -> VARCHAR

---

## ep.03 COUNT(\*) & COUNT(DISTINCT)

### 잘못된 기대

COUNT(\*) 쿼리는 SELECT \* 보다는 빠를 것으로 기대  
오히려 부하가 크고 오래걸린다.

ORM 에서 생성한 COUNT(DISTINCT(id))  
이게 부하가 훨씬 크다.

### COUNT(\*) 성능

일반적으로 SELECT \* 은 limit 과 사용되지만 COUNT (\*) 은그렇지 않다.  
성능은 동일하지만, 데이터가 매우 많아진다면 COUNT (\*) 이 부하가 클 수 있다.

### COUNT(\*) 성능 개선

커버링 인덱스를 활용한다.

> SELECT COUNT(index_column)

하지만, 모든 쿼리를 커버링 인덱스로 튜닝할 수는 없음

### COUNT(\*) vs COUNT(DISTINCT expor)

- COUNT(\*) 은 레코드 건수만 확인
- COUNT(DISTINCT expor) 은 임시 테이블로 중복 제거 후 건수 확인 (많은 메모리와 CPU 자원 사용)

중복 제거용 임시테이블 생성을 위해 내부적으로 insert, update를 더 사용하게 된다.

### COUNT(\*) 튜닝

- 최고의 튜닝은 쿼리 자체를 제거하는 것
- 커버링 인덱스
- 페이징 시 페이지 번호 없이 이전/이후 페이지 이동
- 대략적 건수 사용, 표시할 페이지의 레코드 만큼만 건수 확인
  - select Count(\*) from (select 1 from table limit 200) z;
  - 뒷 페이지 일 수록 느려지겠지만, 앞 쪽 페이지의 조회가 높은 서비스의 경우 효과적
- 임의의 페이지 번호는 표기
  - 페이지를 정확한 건수 기준으로 표기하지 않고 대략적으로 표기
- 통계 정보 이용
  - where조건이 없을 떄, INFORMATION_SCHEME.tables
- 제거 대상
  - where 없는 COUNT(\*)
  - where 일치 건수가 많은 COUNT(\*)
- 인덱스 활용하여 최적화 대상
  - 정확한 COUNT(\*)가 필요
  - COUNT(\*) 대상이 소량
  - where 조건이 인덱스로 커버 가능한 경우

---

## ep.04 페이징 쿼리 작성

### LIMIT & OFFSET

- DBMS 서버에 부하가 크다.
- 순차적으로 레코드를 읽을 수 밖에 없어서 쿼리 실행 횟수가 늘어날수록 점점 더 읽는 데이터가 많아짐
- 다른 방법으로는 범위 기반 방식과 데이터 개수 기반 방식이 있다.

### 범위 기반 방식

- 특정 날짜 범위나 숫자 범위를 기준으로 데이터를 나눠서 조회(where절 활용)
- 주로 배치작업에서 데이터를 날짜 범위로 나눠서 조회할 때 사용
- 여러 번 쿼리를 나누어 실행해도 쿼리가 단순하다.
- 날짜 컬럼으로 잡거나 AutoIncrement 컬럼을 기준으로 나누는 예시.

### 데이터 개수 기반 방식

- 주로 서비스 단에서 order by & limit 절이 사용됨
- n회차 쿼리마다 형태가 달라진다.
- where절에 따라 쿼리 형태가 달라진다.
- order by 컬럼에 pk를 포함시킨다.
- 이전 쿼리의 결과를 사용하여 비교 컬럼을 추가한다.
  - ex) where... and id > {이전 쿼리의 마지막 값} order by id limit 30;
- 범위 조건 사용시에는 쿼리 성능 향상을 위해 날짜 컬럼을 ORDER 시킨다. (인덱스일 경우 활용을 하기 위해)
  - ex) order by finished_at, id limit 30;
- 식별자 컬럼과 범위조건 컬럼의 값 순서가 동일하지 않은 경우에는 쿼리를 조금 더 수정해야한다.

---

## ep.05 Stored Function

- Built-in Function
- UDF
- Stored Function
  - deterministic, 동일 상태와 동일 입력일 때 동일 결과
  - <-> not deterministic

where 조건절에 deterministic 함수를 사용하면 pk를 const 타입으로 접근한다.

pk를 const 타입으로 접근하면 레코드를 1건만 읽는 다는뜻이며, 매우 빠르게 처리된다.

> not deterministic 함수는 풀스캔을 실행한다.

입력에 따라 다른 값을 반환할 수 있기 때문에 모든 row를 비교하면서 함수를 호출한다. 비교 기준 값이 **변수**이기 때문에 인덱스 최적화가 안된다.

not deterministic 으로 선언된 built-in 함수들

- uuid()
- rand()
- now()
- sysdate()
- ...

예외적으로 now() 함수는 하나의 Statement 내에서는 deterministic 처럼 작동한다. (sysdate()로 비교하면 풀스캔)

sysdate-is-now 시스템 설정을 해야 sysdate()도 now()처럼 작동한다.

함수 선언시 디폴트는 Not deterministic 이기 때문에, 옵션을 명시하자

+security 속성과 definer 속성도 정확히 이해하고 꼭 명시하자

---

## ep.06 Lateral Derived Table

- Derived Table: From 절에서 서브쿼리를 통해 생성되는 임시 테이블
- 선행 테이블의 컬럼을 참조할 수 없다.
- LDT는 선행 테이블의 컬럼을 참조할 수 있다.
- 참조한 값을 바탕으로 동적 결과 생성

> SELECT \* FROM t left join LETERAL (select ~ From a where t.column = ?) s;

select 절의 서브쿼리는 하나의 값만 반환할 수 있다.  
이 때 inner join lateral 사용하여 해결 가능하다.

inner join은 문법상 on 절이 선택사항이고,  
left join은 on 절이 필수라 on true 라도 붙여야 한다.

Select 절 내 연산 결과 반복 참조에 사용할 수 있다.  
동일한 연산을 중복하지 않을 수 있다.

> select \*  
> from t,  
>  lateral (select ~) l1,  
>  lateral (select ~) l2;

---

## ep.07 SELECRT .. FOR UPDATE

- MySQL의 SELECT는 기본적으로 잠금 없는 일관된 읽기를 제공.
  - 레코드를 읽고 있는 도중에 다른 세션이 데이터를 변경하지 못하도록 Shared Lock을 걸 수 있지만, 성능이 저하됨.
  - 반대 상황에서는 레코드 변경 세션은 Exclusive Lock을 걸어야 하고, 심각한 성능 저하 유발
  - 이런 동시 처리 성능 개선을 위해 Non-Locking Consistend Read(MVCC)
  - undo 라는 공간에 레코드를 백업하고 읽음
- Repeatable Read 격리수준에서는 하나의 트랜잭션에서 여러번 조회해도 동일한 결과를 반환

> Select .. for [UPDATE | SHARE] 는  
> 항상 격리수준과 무관하게 최신 커밋 데이터 조회  
> 즉, 일반 select와 다른 결과 받게 될 수 있음

### FOR UPDATE

- for update 구문은 exclusive lock 을 걸기 때문에 다른 트랜잭션은 대기하게되는 것.
  - 트랜잭션 내에서 사용되어야만 효과가 있다.
  - Auto-commit 모드에서는 효력이 없는 것과 마찬가지
  - 안 쓸 수 방법이 있을 수 있다.(affected_rows를 확인하는 방법 등)
  - where 조건에 필터링 조건을 잘 넣어서 잠금을 걸지 않도록 할 수 있다.
- Lock Release 조건
  - read-committed
  - binlog_format=MIXED|ROW

### FOR SHARE

- 부모 테이블의 레코드를 확인하고 자식 테이블에 INSERT 할 떄 사용
  - 부모테이블을 조회(for share) 하고 자식테이블 삽입할 때 부모 레코드를 보존하도록.
- 부모레코드를 변경해야하면 for update를 쓰는 게 맞다
  - 공유잠금에서 배타잠금으로 lock-upgrade하게 되면, 데드락 유발한다.

---

## ep.08 Generated 컬럼 & 함수 기반 인덱스

### Generated 컬럼

- 표현식으로 정의된 컬럼. 표현식에 따라 값이 자동 생성
- 유저가 값을 입력하거나 변경 할 수 없음
- 가상컬럼
  - 값을 디스크에 저장하지 않음
  - 인덱스로 지정하면 인덱스는 디스크에 저장
  - 일반 컬럼으로 변환은 불가능
  - 컬럼 추가 또는 변경시 유효성 검사 옵션이 있다.
    - WITH VALIDATION (고비용. 전체 복사함)
    - WITHOUT VALIDATION
- 스토어드 컬럼
  - 값을 디스크에 저장
- 가상 - 스토어드간의 변경 불가능
- 컬럼에 적용된 표현식을 완전히 일치하도록 쿼리에 사용하면 인덱스 활용됨. 조건값과 컬럼타입도 일치해야한다.

DDL 작업을 진행할 때는 알고리즘 명시하는 것이 좋다.

### 함수 기반 인덱스

- 내부적으로 가상컬럼을 만들게 된다.
- 표현식에 비결정적 함수 사용 불가
- prefix 길이 지정된 컬럼은 키 값으로 지정 불가
- pk에 표현식 지정은 불가하다.

---

## ep.09 ERROR HANDLING

- Global Error (Error No 1 ~999)
- Server Error (Error No 1000 ~1999)
  - 일부 서버에러는 클라이언트로 전달됨
- Client Error (Error No 2000 ~2999)

### SQL state

5글자 영문 숫자로 벤더 비 의존적 에러코드

### 에러 핸들링

- 에러 메시지를 이용한 에러 핸들링은 위험하다.
  - 버전별로 메시지 다름
- 에러 넘버로 핸들링하는 것도 적합하지 않다.
  - 스토리지 엔진에 종속적인 경우 많다.
- SQL state 핸들링
  - 가장 적합, 엔진간 호환성 제공. DBMS 다르면 다를 수 있음
  - HY로 시작하는 경우도 적합하지 않음(미분류 상태) 이 때는 차라리 ErrorNo로 핸들링

무엇보다 DBA와 소통시에 잘 활용하자(Error No, state 등)  
DB에러 반드시 로깅  
SQL 예외를 버리지 말고 래핑해서 예외처리

---

## ep.10 LEFT JOIN 주의사항 & 튜닝

조인 대상 테이블에 대한 조건을 on 절에 넣을 때와 where 절에 넣을 때의 의도를 잘 구분해서 사용하자 (떼론 옵티마이저가 자동으로 Inner 로 변경함)

항상 아우터 테이블을 먼저 읽는다.  
반면 Inner join은 읽는 순서가 고정되지 않아 인덱스 할용이 다를 수 있다. (옵티마이저에 의해)

count 등을 사용할 떄 결과가 같다면 조인문을 제거하는 것을 고려해보자

---

## ep.11 Prepared Statement

장점: preparedStatement 객체를 사용하여, SQL 인젝션 방지 및 쿼리 파싱 비용 감소

단점: 메모리, 2번의 커넥션, 캐싱안됨(parse-tree만 캐싱) 캐시된 preparedStatement는 커넥션 내에서만 공유된다.

ServerSide-PreparedStatement를 사용하는지 ORM 옵션 확인(보통 디폴트로 켜져있긴 하다.)

> Parse-Tree는 캐시가 되니, 캐시를 재활용하도록 코딩해야한다.

### PreparedStatement vs ConnectionPool

- ps는 하나의 커넥션에서만 공유된다.
- ps는 Re-parsing 비용 최소화
  - 커넥션 개수와 쿼리 패턴의 개수를 파악하여 max_prepared_stmt_count 옵션 늘려야함
- 쿼리가 복잡하면 ps가 좋지만 단순하면 장점이 경감
- ps는 메모리도 많이 차지할 수 있다.

Server-side ps는 부작용이 심한 경우 많음(OOM 등)  
Client-side ps는 권장 (둘 다 인젝션은 막아줌)

---

## ep.12 SQL 문장의 가독성 향상

1. DISTINCT를 함수처럼 사용하는 형태 지양 (괄호 지양)

괄호를 사용해도 결과가 동일하고, MySQL 서버는 어차피 실행시 괄호를 제거함.  
괄호사용의 오해의 여지가 있을 수 있다.

2. LEFT JOIN 사용 방법 준수

드리븐 테이블(대상)의 대한 조건을 Where절에 사용하면 INNER JOIN과 동일한 결과 출력된다.  
1:1로 LeftJoin하면서 count를 하거나 드리븐 테이블의 컬럼만 조회하는 것은 비효율적이고 가독성을 해친다.(조인필요없음)

3. ORDER BY 없이 LIMIT n,m 문법 지양

의도 파악이 어렵다. 페이징을 위해서라면 ORDER BY 사용해야한다.

4. FULL GROUP BY 형태로 사용

Group by 절에 명시되지 않은 컬럼을 SELECT 절에서 참조하는 경우엔 의도에 맞게 집계함수를 반드시 사용해야한다. 불필요한 컬럼이면 제거한다.  
ANY_VALUE()를 사용해서 랜덤값을 가져올 수도 있다.

5. AND/OR 조건 함께 사용시 반드시 괄호 명시

AND 연산이 우선 순위가 높아서 의도치 않게 동작할 수 있다.

6. 데이터 건수 조회는 COUNT(\*) 사용

count 함수의 인자로 특정 컬럼이나 1과같은 상수를 사용하는 경우, 의도파악이 어렵다.  
전체 건수가 필요한 경우 \* 을 사용하자.

---

## ep.13 콜레이션

- 문자를 비교하거나 정렬할 때 사용되는 규칙
- 문자 집합에 종속적.
  - 문자집합이란? 문자와 코드값의 조합이 정의되어 있는 것
- MySQL 모든 문자열 타입 컬럼은 독립적인 문자집합과 콜레이션을 가질 수 있음
- 사용자가 지정하지 않을 경우 서버의 디폴트로 지정됨
- SHOW COLLATION 명령을 통해 사용 가능한 콜레이션 목록 확인 가능
- 네이밍컨벤션: (문자집합*언어종속\_UCA버전*민감도)
- 코드 포인트 값을 인코딩해서 데이터 저장 (유니코드 기준)
- 문자에 대한 가중치 값을 통한 데이터 비교 (유니코드 기준)
  - 가중치확인: HEX(WEIGHT_STRING(column1))
- 서로 다른 콜레이션의 컬럼을 비교하면 에러 발생
- WHERE 절에서 콜레이션 변경시 인덱스 사용 불가능
  - 애초에 함수기반 인덱스로 생성하면 가능
- 콜레이션에 따라 데이터의 중복 여부를 판단하는데 영향을 미친다 (대소문자 등등)
- utfmb4-0900-ai-ci 콜레이션은 '가'와 'ㄱㅏ'가 동일하게 인식된다.
  - utfmb4-0900-as-cs 에서는 해결된다.
- utfmb4-0900-ai-ci는 대소문자를 구분하지 않는다.
  - 다른 콜레이션 사용

---

## ep.14 UUID 사용 주의사항

- UUID: 128비트의 이진값인데 16진수로 표현
- 버전 1 & 2: 타임스탬프 기반으로 생성(+ 맥 어드레스)
- 버전 3 & 5: MD5, SHA-1 해시알고리즘으로 생성(입력 필요)
- 버전 4: 완전 랜덤
- CHAR(32) or VARCHAR(32)

- B-tree 인덱스의 성능 저해 요소

  - 정렬되지 않은 값
  - 길이가 긴 값
  - 유니크제약이 필요
    - 유니크 제약을 가진 경우에는 인덱스에 ChangeBuff를 사용할 수 없어서 성능저하
  - uuid가 Pk 로 사용되면 모든 보조인덱스는 pk를 포함하게 된다.(공간 너무 차지함)
  - 전체 인덱스가 워킹셋이된다. (전부 메모리에 올려야함)

- 버전6: 최종 IETF 드랍되었으나 시도는 좋았다

  - 최근에는 UUID_TO_BIN(), BIN_TO_UUID 출시
    - 타임스탬프 재배치 후 테이블의 저장 및 조회(워킹셋 절약)

- 너무 길어서 데이터가 엄청 쌓이게 될 경우 돌이키기 어렵다.

### 대안

- BIGINT uid
- auto_increment
  - 단조 증가라 데이터 예측가능 예측가능하긴 해도 가장 쉬운 대안
- snowflake-uid
- sonyflake-uid
- timestamp based in-house INT64 uid
- timastamp prefix
  - 파티션에 활용하기 좋다(레인지 파티션). 그 자체가 파티션키가 될 수 있음

꼭 필요하다면, autoincrement를 PK로 사용하고 uuid 유니크 인덱스 사용을 권장

---

## ep.15 풀스캔 쿼리 패턴 및 튜닝

### 풀스캔으로 처리되는 쿼리

- 컬럼이 가공되는 경우

  - 컬럼에 산술연산, 함수의 인자로 컬럼, 컬럼 형변환 수행 (내부적으로 형변환 우선순위에 따라 다르긴하다. 문자>숫자 변환이 우선)

- 인덱싱 되지 않은 컬럼을 조건절에 OR 연산과 함께 사용할 경우

- 복합 인덱스의 컬럼중 선행 컬럼을 조건에서 누락할 경우

- LIKE 연산에서 시작 문자열로 와일드 카드를 사용할 경우
- 정규식 연산을 사용하는 경우
  > 데이터 분포에 따라 옵티마이저의 판단으로 풀스캔이 일어날 수 있다.

---

## ep.16 COUNT(\*) vs COUNT(col)

count의 인자로 들어온 컬럼 중 NULL이 아닌 값만 반환하기 때문에 결과가 다를 수 있다. (select count(null) > 0)

Nullable 컬럼으로 count를 호출하면 성능이 매우낮다.(실행계획은 같더라도)

MySQL 8.0버전은 조건없는 conut() 쿼리에 대해 병렬처리 지원

count(\*)이 항상 좋은 성능을 해낼 가능성이 높음. (항상 컬럼 추출 수행하지 않음)

count(\*) 쿼리에서도 인덱스를 사용할 수 있도록 튜닝하라

현재, 버그가 있다. 실행계획과는 다르게 조건 없는 count 쿼리는 항상 pk 를 이용하도록 고정되어있다.

데이터를 인덱스에서 읽을 떄(커버링인덱스) 성능이 훨씬 좋다.  
실행계획의 Extra: Using index

count(1), sum(1)도 성능과 결과는 동일하지만, 쿼리의 의도파악에 헷갈릴 수 있다.

---

## ep.17 NOWAIT & SKIP LOCKED

### SELECT ... FOR UPDATE NOWAIT

잠금을 대기하지 않고 바로 에러를 반환한다.  
이 때 트랜잭션이 종료되지 않는다. 명시적으로 커밋 또는 롤백을 해야한다.

### SELECT ... FOR UPDATE SKIP LOCKED

잠금이 걸려있는 레코드는 스킵하고, 잠금이 걸려있지 않은 레코드를 잠그고 결과를 반환  
모든 레코드가 잠가져 있는 경우 빈 결과를 반환하지만, 레코드 사이 간격을 잠그는 *갭락*을 점유할 수 있다.  

order by / limit 절과 많이 사용된다. 바로 다음 레코드를 잠그고 사용할 수 있도록 (예시: 쿠폰발급, 배치잡을 테이블에 저장해놓고 실행할 때)

### With JOIN

1:N 조인을 *SKIP LOCKED* 와 사용했을 때, 상위 테이블에 잠금이 걸리게 되어 의도한 대로 동작하지 않는다.

*OF* 구문을 통해 상위 테이블의 잠금을 예외시켜 해결할 수 있다.

---

## ep.18 UNION vs UNION ALL

특정 조건을 만족하면 임시 테이블을 통한 가공 작업없이 UNION 결과를 빠르게 가져올 수 있다.

- UNION ALL
결과에서 중복을 제거하지 않아서 결과를 빠르게 반환

- UNION DISTINCT
중복을 제거해야 하기 때문에 임시 테이블에서 정렬과 검사를 거쳐야한다.  
중복의 기준은 모든 컬럼이다. 모든 컬럼이 같아야 중복(내부적으로 모든 컬럼의 복합 유니크키 생성)

UNION ALL은 MySQL 서버에서 쿼리가 실행되는 도중에 결과를 다운로드할 수 있지만,  
UNION DISTINCT는 처리가 완료되어야만 결과를 받을 수 있다.

> UNION 뒤의 키워드를 생략하면 DISTINCT 로 수행된다.

