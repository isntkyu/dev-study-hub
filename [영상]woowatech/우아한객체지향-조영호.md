# 우아한 객체지향- 조영호

[https://youtu.be/dJ5C4qRqAgA](https://youtu.be/dJ5C4qRqAgA)

### 의존성을 이용해 설계 진화시키기

[https://github.com/eternity-oop](https://github.com/eternity-oop)

변경에 초점을 맞추기

의존의 의미: 변경에 의한 영향

연관관계: a에서 b 로 영구적으로 갈 수 있는 경로 존재

의존관계: 일시적으로 협력할 수 있는 시점에 연결

상속관계: 구현이 영향

실체화 관계: implements, 시그니쳐가 바뀌어야 영향을 받음

패키지 사이의 관계

A패키지안의 클래스가 B패키지에 의존성이 있다면 패키지간에 의존성이 있는 것.

(simple 하게는 import 한다.)

양방향 의존성을 피하라

다중성이 적은 방향을 선택하라

- A가 B의 리스트를 가지는것 보단 B가 A를 참조하는 방법을 선택(다대일)
- 의존성이 필요없다는 제거하는것이 가장 좋음

패키지사이의 의존성 사이클을 제거하라.

- 단방향으로

---

배민 예시

상황: 사장이 등록한 메뉴와 휴대폰 장바구니 메뉴의 차이 발생가능 → 검증 필요함(메뉴, 옵션)

추가적으로 최소주문금액, 영업여부까지 확인 후 주문가능.

관계에는 방향성이 필요

- 협력의 방향, 의존성의방향

연관관계(개념적인 것)

- 탐색가능성
- 두 객체간의 통로가 영구적,
- 객체 참조(구현방법중 하나)

객체에 메소드가 필요한 이유는 메시지가 필요하기 떄문

메시지를 결정하고 메소드를 만드는게 맞다.

---

설계 개선하기

디펜던시를 쭉 그려보고 개선할 점 찾기.

코드작성 후 의존성 관점에서 설계 검토

- 각체 참조로인한 결합도 상승
- 패키지 의존성 사이클
  - 중간 객체를 이용한 의존성 사이클 끊기

추상화: 추상클래스, 인터페이스뿐아니라 변하지 않는 것을 정의한것

연관관계 살피기

- 탐색 가능 (order가 뭔지알면 orderItem을 찾을 수 있는것)

객체 참조로 구현한연관관계의 문제점

- 어디까지 조회할 것인가. (orm 연결시)
- 객체의 수정 범위 문제

도메인간 묶여(객체참조)있는 (ex. shop-order-delivery) 트랜잭션에서 각 도메인마다 변경으 빈도가 다르다.

트랜잭션 경합으로 인한 성능 저하.

객체 참조는 결합도가 가장 높은 의존성.

Repository를 통한 탐색(약한 결합)

어떤 객체를 묶고 어떤객체를 분리할 것인가.

- 도메인을 기준으로 분류
- 함께 생성되고 함께 삭제되는 객체 묶기 (같이 트랜잭션을 묶어야하는 경우 or cascade)
- 도메인 제약사항을 공유하는 객체를 묶어라.
- 가능하면 분리
- id를 이용한 연관관계 설정 (repository)

하나의 단위로 묶어서 몽고디비에 저장하는 것도 방법(트랜잭션단위)

컴파일에러가 날것.

- 객체를 참조하는 로직을 다른 객체로 옮기자 ( .)
  - 전체 로직을 모아서 볼 수 있음
  - 절차지향이 객체지향보다 좋은 케이스.
  - 낮은 응집도를 높은 응집도로 바꿈
- 도메인 로직의 순차적 실행.
  - 절차지향 사용
    - 인터페이스를 만들어서 의존성을 역전시키자. (싸이클 해결)
  - 도메인 이벤트 퍼블리싱
    - 패키지 분리(싸이클 해결)
