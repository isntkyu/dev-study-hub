## 도메인 주도 설계 철저 입문

나루세 마시노부

---

### 값 객체

### 값의 성질

- 불변
- 주고받을 수 있다. (대입)
- 등가성 비교 가능

값은 변하지 않는다. 변수에 값을 대체할 뿐이다.

값 객체에는 행동이 정의될 수 있다. ex) Money객체의 add() 함수

### 값 객체 도입의 장점

- 표현력이 증가된다.
- 무결성이 유지된다.
- 잘못된 대입을 방지한다 (타입체크)
- 로직이 코드 이곳저곳에 흩어지는 곳을 방지한다. (DRY)

`타입스크립트와 잘 어울리는 것 같다는 생각이 들었다.`

---

### 엔티티

속성이 아닌 동일성으로 식별되는 도메인 객체. (값 객체도 도메인 객체)
예를 들어, '사용자'는 사용자 이름이나 나이 등 정보가 변경되어도 사용자가 변경된 것이 아니다.
(값 객체는 반대이다. 속성들이 모두 같으면 같은 것이다.)

엔티티의 성질

- 가변
- 속성이 같아도 구분됨
- 동일성을 통해 구별됨
- 생애주기를 가짐

값 객체도 될 수 있고 엔티티도 될 수 있는 도메인 모델이 있다.

도메인 객체를 정의할 때 장점

- 자기 서술적인 코드가 된다.
- 도메인에 변경사항이 있을 시 코드에 반영하기 쉽다.

---

### 도메인 서비스

일반적으로 애플리케이션 서비스와 달리 개발계층에서의 서비스를 의미한다. (ex. userService)

값 객체, 엔티티에 있어야할 행동은 값 객체, 엔티티에 넣되 그러기 애매한 행동을 정의하기 위한 객체이다.  
남용해서도 안되며, 행동을 어디에 구현할지 어색하지 않게 명확히 판단하자.

데이터스토어 입출력 등은 도메인이 아닌 애플리케이션의 관심사이기 때문에 가능한 한 도메인 객체에서 다루지 않는다.

도메인 객체의 행동을 모두 서비스로 옮길 수 있지만,  
도메인 객체가 게터, 세터만 갖고있는 빈혈 도메인 모델이 되고  
행위가 빈약한 객체는 절차적 프로그램이으로 빠지기 쉽다.

---

### 리포지토리

---

### 애플리케이션 서비스

도메인 객체를 공개하지 않는 편이 좋다.  
애플리케이션 서비스만이 도메인객체의 행동을 호출할 수 있다.

DTO를 사용하자는 뜻(공개할 데이터만을 담은 객체, 도메인 객체를 인자로 받아서 생성한다)

수정API 인자로 커맨드 객체를 사용한다.  
updateRequestDto의 속성 null 체크를 통해 업데이트할 항목을 식별하여 업데이트하는 맥락과 비슷함.

도메인규칙(이름 중복금지, 이메일중복금지 등)을 애플리케이션 서비스에 구현하지 않는다. 코드 중복발생확률이 매우 높다.  
도메인 서비스에 숨긴다.(exist함수 등)

응집도를 계산하여 클래스 분리를 고려해보기

클라이언트는 애플리케이션 서비스의 인터페이스를 통해 호출한다.

---

### 의존 관계 제어

추상 타입에 의존하도록 하여 의존 관계 를 제어하는것 (ex. IRepository, 데이터스토어 구현체를 갈아끼워도 되게) 의존관계 역전원칙 이라고 한다.  
(+ 추상화 수준이 높은 모듈이 낮은 모듈에 의존하면 안된다.)

#### ServiceLocator패턴

애플리케이션 시작시 미리 등록된 인스턴스를 ServiceLocator로부터 가져온다.

- 의존관계를 외부에서 보기 어렵다.
  - 의존관계 해소대상 인스턴스가 설정되어 있지 않는 등의 경우
- 테스트 유지가 어렵다
  - 같은 이유

#### 해결: IOC container 패턴

마찬가지로 시작스크립트를 이용, 컨테이너가 의존관계가 해소된 인스턴스를 리턴

---

### 팩토리 패턴

팩토리 패턴이 필요하지는 않은지 검토하는 습관을 들이자

---

### 데이터의 무결성 유지하기

방법1: 유일키  
유일키는 강력하지만 유일키만 믿고 애플리케이션에서 중복확인을 하지 않는 행위는 하지 말자 (기술에 의존하지 말자)

방법2: 트랜잭션  
트랜잭션을 사용하면 서비스범위까지 인프라기술이 의존된다 (커넥션) -> 해법: AOP, 유닛오브워크(c#)

---

### 애플리케이션 만들기

요구사항 -> 유스케이스수립 -> 도메인객체 정의 -> 서비스 구현  
유스케이스를 구현시 커맨드 객체로 구현

---

### 애그리게이트

여러 객체가 불변조건을 유지하는 조건안에 모인 집합  
경계: 애그리게이트에 포함을 결정하는 조건  
루트: 애그리게이트에 포함되는 객체를 외부에 노출하지 않고 루트를 거쳐야 한다.  
애그리게이트 다이어그램은 모델을 나타내는 것이지 코드를 나타내는 것이 아니다.

데메테르의 법칙  
다음 객체의 메서드만을 호출할 수 있게 제한

- 객체 자신
- 인자로 전달받은 객체
- 인스턴스 변수
- 해당 컨텍스트에서 직접 생성한 객체

게터를 통해 필드를 공개하면 객체에 구현되어야 할 규칙이 다른 곳에서 중복구현 되는 일을 막을 수 없다.

내부변수를 공개하면 안된다. 하지만 공개하지 않고 레포지토리에 어떻게 전달할까?  
-> 노티피케이션 객체와 인터페이스를 이용한다. 레포지토리는 노티피케이션 메소드를 통해 데이터를 받아와서 저장한다.

경계를 결정하는 기준은 변경의 단위이다.  
레포지토리는 애그리게이션마다 하나씩이다.  
컴포지션은 식별자를 이용한다.  
애그리게이트의 범위는 작을 수록 좋다.  
트랜잭션에서 여러 애그리게이트를 다루는 것도 피한다.

---

### 명세

객체의 평가 기준을 만족하는지 판정하는 객체  
엔티티나 값객체가 리포지토리를 다루지 않으면서도 도메인 규칙을 가질 문제를 해결할 수 있다.  
평가 코드를 캡슐화 하는 것.  
리포지토리는 가능한 사용하지 않는다.  
리포지토리 구현체에 중요한 로직이 들어갈 경우에도 명세를 조합한다.  
명세를 레포지토리의 필터로 이용할 때는 성능에 유의.

지연실행: 컬렉션을 미리 만들고 실제로 데이터가 필요한 시점에 쿼리실행, 전부 조회하고 나중에 조건을 입히는 작업시 유용

클라이언트 편의를 우선

---

### 아키텍처

- 계층형 아키텍처
  - 프레젠테이션
  - 애플리케이션
  - 도메인
  - 인프라스트럭쳐
- 헥사고날 아키텍처
  - 저장매체나 입출력 장치를 자유롭게 바꿔도 무관한 형태의 육각형 모델을 예시(게임기처럼)
  - 포트앤 어댑터
  - 인터페이스를 통한 DIP를 적용해야 한다는 것
- 클린 아키텍처
  - 의존관계의 방향을 안쪽으로 하는 원 형태의 아키텍처로 세부사항이 추상에 의존하는 DIP 달성
  - 헥사고날과 컨셉이 같다
  - 서비스의 메서드를 구현하는 Interactor 객체로 output(presenter) 객체에도 의존
  - Interactor 스텁을 만들 수 있어 테스트가 용이

---

부록. 패키지 구조 솔루션 구성

클래스의 성격만으로 같은 패키지에 배치하지 말고, 의미적 유사성을 고려하라  
같은 이유로 명세와 도메인 객체는 같이 있는다.
