## 도메인 주도 설계 철저 입문

나루세 마시노부

---

### 값 객체

### 값의 성질

- 불변
- 주고받을 수 있다. (대입)
- 등가성 비교 가능

값은 변하지 않는다. 변수에 값을 대체할 뿐이다.

값 객체에는 행동이 정의될 수 있다. ex) Money객체의 add() 함수

### 값 객체 도입의 장점

- 표현력이 증가된다.
- 무결성이 유지된다.
- 잘못된 대입을 방지한다 (타입체크)
- 로직이 코드 이곳저곳에 흩어지는 곳을 방지한다. (DRY)

`타입스크립트와 잘 어울리는 것 같다는 생각이 들었다.`

---

### 엔티티

속성이 아닌 동일성으로 식별되는 도메인 객체. (값 객체도 도메인 객체)
예를 들어, '사용자'는 사용자 이름이나 나이 등 정보가 변경되어도 사용자가 변경된 것이 아니다.
(값 객체는 반대이다. 속성들이 모두 같으면 같은 것이다.)

엔티티의 성질

- 가변
- 속성이 같아도 구분됨
- 동일성을 통해 구별됨
- 생애주기를 가짐

값 객체도 될 수 있고 엔티티도 될 수 있는 도메인 모델이 있다.

도메인 객체를 정의할 때 장점

- 자기 서술적인 코드가 된다.
- 도메인에 변경사항이 있을 시 코드에 반영하기 쉽다.

---

### 도메인 서비스

일반적으로 애플리케이션 서비스와 달리 개발계층에서의 서비스를 의미한다. (ex. userService)

값 객체, 엔티티에 있어야할 행동은 값 객체, 엔티티에 넣되 그러기 애매한 행동을 정의하기 위한 객체이다.  
남용해서도 안되며, 행동을 어디에 구현할지 어색하지 않게 명확히 판단하자.

데이터스토어 입출력 등은 도메인이 아닌 애플리케이션의 관심사이기 때문에 가능한 한 도메인 객체에서 다루지 않는다.

도메인 객체의 행동을 모두 서비스로 옮길 수 있지만,  
도메인 객체가 게터, 세터만 갖고있는 빈혈 도메인 모델이 되고  
행위가 빈약한 객체는 절차적 프로그램이으로 빠지기 쉽다.

---

### 리포지토리

---

### 애플리케이션 서비스

도메인 객체를 공개하지 않는 편이 좋다.  
애플리케이션 서비스만이 도메인객체의 행동을 호출할 수 있다.

DTO를 사용하자는 뜻(공개할 데이터만을 담은 객체, 도메인 객체를 인자로 받아서 생성한다)

수정API 인자로 커맨드 객체를 사용한다.  
updateRequestDto의 속성 null 체크를 통해 업데이트할 항목을 식별하여 업데이트하는 맥락과 비슷함.

도메인규칙(이름 중복금지, 이메일중복금지 등)을 애플리케이션 서비스에 구현하지 않는다. 코드 중복발생확률이 매우 높다.  
도메인 서비스에 숨긴다.(exist함수 등)

응집도를 계산하여 클래스 분리를 고려해보기

클라이언트는 애플리케이션 서비스의 인터페이스를 통해 호출한다.

---

### 의존 관계 제어

추상 타입에 의존하도록 하여 의존 관계 를 제어하는것 (ex. IRepository, 데이터스토어 구현체를 갈아끼워도 되게) 의존관계 역전원칙 이라고 한다.  
(+ 추상화 수준이 높은 모듈이 낮은 모듈에 의존하면 안된다.)

#### ServiceLocator패턴

애플리케이션 시작시 미리 등록된 인스턴스를 ServiceLocator로부터 가져온다.

- 의존관계를 외부에서 보기 어렵다.
  - 의존관계 해소대상 인스턴스가 설정되어 있지 않는 등의 경우
- 테스트 유지가 어렵다
  - 같은 이유

#### 해결: IOC container 패턴

마찬가지로 시작스크립트를 이용, 컨테이너가 의존관계가 해소된 인스턴스를 리턴
